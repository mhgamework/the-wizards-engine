<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SharpDX.DXGI</name>
    </assembly>
    <members>
        <member name="T:SharpDX.DXGI.Adapter">
            <summary>	
            The  IDXGIAdapter interface represents a display sub-system (including one or more GPU's, DACs and video memory).	
            </summary>	
            <unmanaged>IDXGIAdapter</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.DXGIObject">
            <summary>	
            An IDXGIObject interface is a base interface for all DXGI objects; IDXGIObject supports associating caller-defined (private data) with an object and retrieval of an interface to the parent object.	
            </summary>	
            <unmanaged>IDXGIObject</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.DXGIObject.GetParent``1">
            <summary>
            </summary>
            <typeparam name = "T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:SharpDX.DXGI.DXGIObject.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.DXGIObject"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.DXGIObject.SetPrivateData(System.Guid,System.Int32,System.IntPtr)">
            <summary>	
            Sets an IUnknown interface as private data; this associates application-defined data with the object.	
            </summary>	
            <remarks>	
            This API makes a copy of the specified data and stores it with the object. 	
            </remarks>	
            <param name="name">A GUID identifying the data. This GUID will also be used when getting the data. </param>
            <param name="dataSize">The size of the object's data. </param>
            <param name="dataRef">Pointer to the object's data. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIObject::SetPrivateData([In] GUID* Name,[None] int DataSize,[In, Buffer] const void* pData)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.DXGIObject.SetPrivateDataInterface(System.Guid,SharpDX.ComObject)">
            <summary>	
            Set an interface in the object's private data.	
            </summary>	
            <remarks>	
            This API associates an interface reference with the object. When the interface is set its reference count is incremented. When the data are overwritten (by calling SPD or SPDI with the same GUID) or the object is destroyed, ::Release() is called and the interface's reference count is decremented. 	
            </remarks>	
            <param name="name">A GUID identifying the interface. </param>
            <param name="unknownRef">The interface to set. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIObject::SetPrivateDataInterface([In] GUID* Name,[In] const IUnknown* pUnknown)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.DXGIObject.GetPrivateData(System.Guid,System.Int32@,System.IntPtr)">
            <summary>	
            Get a reference to the object's data.	
            </summary>	
            <remarks>	
            If the data returned is a reference to an IUnknown, or one of its derivative classes, previously set by <see cref="M:SharpDX.DXGI.DXGIObject.SetPrivateDataInterface(System.Guid,SharpDX.ComObject)"/>, then ::Release() must be called on the reference before the reference is freed to decrement the reference count. 	
            </remarks>	
            <param name="name">A GUID identifying the data. </param>
            <param name="dataSizeRef">The size of the data. </param>
            <param name="dataRef">Pointer to the data. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIObject::GetPrivateData([In] GUID* Name,[InOut] int* pDataSize,[Out, Buffer] void* pData)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.DXGIObject.GetParent(System.Guid,System.IntPtr@)">
            <summary>	
            Gets the parent of the object.	
            </summary>	
            <remarks>	
            The following diagram shows the possible parent types for DXGI objects. ?  Diagram of possible parents for DXGI objects ? The identifier of the interface an object supports can be obtained like so: 	
            <code> __uuidof(*ppParent) </code>	
            	
             	
            </remarks>	
            <param name="riid">The ID of the requested interface. See remarks. </param>
            <param name="parentRef">The address of a reference to the parent object. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIObject::GetParent([In] GUID* riid,[Out] void** ppParent)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Adapter.IsInterfaceSupported(System.Type)">
            <summary>	
            Checks to see if a device interface for a graphics component is supported by the system.	
            </summary>	
            <param name="type">The GUID of the interface of the device version for which support is being checked. For example, typeof(ID3D10Device).GUID. </param>
            <returns>
            	<c>true</c> if the interface is supported; otherwise, <c>false</c>.
            </returns>
            <unmanaged>HRESULT IDXGIAdapter::CheckInterfaceSupport([In] GUID* InterfaceName,[Out] __int64* pUMDVersion)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Adapter.IsInterfaceSupported``1">
            <summary>	
            Checks to see if a device interface for a graphics component is supported by the system.	
            </summary>	
            <typeparam name="T">the interface of the device version for which support is being checked.</typeparam>
            <returns>
            	<c>true</c> if the interface is supported; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:SharpDX.DXGI.Adapter.IsInterfaceSupported``1(System.Int64@)">
            <summary>	
            Checks to see if a device interface for a graphics component is supported by the system.	
            </summary>	
            <typeparam name="T">the interface of the device version for which support is being checked.</typeparam>
            <param name="userModeVersion">The user mode driver version of InterfaceName. This is only returned if the interface is supported.</param>
            <returns>
            	<c>true</c> if the interface is supported; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:SharpDX.DXGI.Adapter.IsInterfaceSupported(System.Type,System.Int64@)">
            <summary>	
            Checks to see if a device interface for a graphics component is supported by the system.	
            </summary>	
            <param name="type">The GUID of the interface of the device version for which support is being checked. For example, typeof(ID3D10Device).GUID. </param>
            <param name="userModeVersion">The user mode driver version of InterfaceName. This is only returned if the interface is supported.</param>
            <returns>
            	<c>true</c> if the interface is supported; otherwise, <c>false</c>.
            </returns>
            <unmanaged>HRESULT IDXGIAdapter::CheckInterfaceSupport([In] GUID* InterfaceName,[Out] __int64* pUMDVersion)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Adapter.GetOutputCount">
            <summary>
              Return the number of available outputs from this adapter.
            </summary>
            <returns>The number of outputs</returns>
        </member>
        <member name="M:SharpDX.DXGI.Adapter.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.Adapter"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.Adapter.GetOutput(System.Int32)">
            <summary>	
            Enumerate adapter (video card) outputs.	
            </summary>	
            <remarks>	
            If the method succeeds, the reference count on the output interface will be incremented. To avoid a memory leak, be sure to release the interface when you are finished with it. Here is an example of how to use this function to enumerate all the outputs on an adapter: 	
            <code> UINT i = 0;	
            IDXGIOutput * pOutput;	
            std::vector&lt;IDXGIOutput*&gt; vOutputs;	
            while(pAdapter-&gt;EnumOutputs(i, &amp;pOutput) != DXGI_ERROR_NOT_FOUND)	
            { vOutputs.push_back(pOutput); ++i;	
            } </code>	
            	
             	
            </remarks>	
            <param name="output">The index of the output. </param>
            <returns>The address of a reference to an output (see <see cref="T:SharpDX.DXGI.Output"/>). </returns>
            <unmanaged>HRESULT IDXGIAdapter::EnumOutputs([None] int Output,[Out] IDXGIOutput** ppOutput)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Adapter.GetDescription(SharpDX.DXGI.AdapterDescription@)">
            <summary>	
            Gets a DXGI 1.0 description of an adapter (or video card).	
            </summary>	
            <remarks>	
            Graphics applications can use the DXGI API to retrieve an accurate set of graphics memory  values on systems that have WDDM drivers. The following are the critical steps involved.   Graphics driver model determination ? Because DXGI is only available on systems with WDDM drivers, the application must first confirm the driver model by using the following API. 	
            <code> HasWDDMDriver()	
            { LPDIRECT3DCREATE9EX pD3D9Create9Ex = NULL; HMODULE             hD3D9          = NULL; hD3D9 = LoadLibrary( L"d3d9.dll" ); if ( NULL == hD3D9 ) { return false; } // /*  Try to create IDirect3D9Ex interface (also known as a DX9L interface). This interface can only be created if the driver is a WDDM driver. */ // pD3D9Create9Ex = (LPDIRECT3DCREATE9EX) GetProcAddress( hD3D9, "Direct3DCreate9Ex" ); return pD3D9Create9Ex != NULL;	
            } </code>	
            	
               Retrieval of graphics memory values.? After the driver model is determined to be WDDM, the application can use the DirectX 10 or later API and DXGI to get the amount of graphics memory.  After creating a Direct3D device the following code can be used to obtain  a <see cref="T:SharpDX.DXGI.AdapterDescription"/> structure containing the amount of available graphics memory. 	
            <code> IDXGIDevice * pDXGIDevice;	
            hr = g_pd3dDevice-&gt;QueryInterface(__uuidof(IDXGIDevice), (void **)&amp;pDXGIDevice);	
            IDXGIAdapter * pDXGIAdapter;	
            pDXGIDevice-&gt;GetAdapter(&amp;pDXGIAdapter);	
            DXGI_ADAPTER_DESC adapterDesc;	
            pDXGIAdapter-&gt;GetDesc(&amp;adapterDesc); </code>	
            	
               	
            </remarks>	
            <param name="descRef">A reference to a <see cref="T:SharpDX.DXGI.AdapterDescription"/> structure that describes the adapter. This parameter must not be NULL. </param>
            <returns>Returns S_OK if successful; otherwise returns an error code.  Returns <see cref="F:SharpDX.DXGI.DXGIError.InvalidCall"/> if the pDesc parameter is NULL.   For a list of error codes, see DXGI_ERROR. </returns>
            <unmanaged>HRESULT IDXGIAdapter::GetDesc([Out] DXGI_ADAPTER_DESC* pDesc)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Adapter.CheckInterfaceSupport(System.Guid,System.Int64@)">
            <summary>	
            Checks to see if a device interface for a graphics component is supported by the system.	
            </summary>	
            <param name="interfaceName">The GUID of the interface of the device version for which support is being checked. For example, __uuidof(ID3D10Device). </param>
            <param name="uMDVersionRef">The user mode driver version of InterfaceName. This is only returned if the interface is supported. This parameter can be NULL. </param>
            <returns>S_OK indicates that the interface is supported, otherwise DXGI_ERROR_UNSUPPORTED is returned (See <see cref="T:SharpDX.DXGI.DXGIError"/>). </returns>
            <unmanaged>HRESULT IDXGIAdapter::CheckInterfaceSupport([In] GUID* InterfaceName,[Out] __int64* pUMDVersion)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.Adapter.Description">
            <summary>	
            Gets a DXGI 1.0 description of an adapter (or video card).	
            </summary>	
            <remarks>	
            Graphics applications can use the DXGI API to retrieve an accurate set of graphics memory  values on systems that have WDDM drivers. The following are the critical steps involved.   Graphics driver model determination ? Because DXGI is only available on systems with WDDM drivers, the application must first confirm the driver model by using the following API. 	
            <code> HasWDDMDriver()	
            { LPDIRECT3DCREATE9EX pD3D9Create9Ex = NULL; HMODULE             hD3D9          = NULL; hD3D9 = LoadLibrary( L"d3d9.dll" ); if ( NULL == hD3D9 ) { return false; } // /*  Try to create IDirect3D9Ex interface (also known as a DX9L interface). This interface can only be created if the driver is a WDDM driver. */ // pD3D9Create9Ex = (LPDIRECT3DCREATE9EX) GetProcAddress( hD3D9, "Direct3DCreate9Ex" ); return pD3D9Create9Ex != NULL;	
            } </code>	
            	
               Retrieval of graphics memory values.? After the driver model is determined to be WDDM, the application can use the DirectX 10 or later API and DXGI to get the amount of graphics memory.  After creating a Direct3D device the following code can be used to obtain  a <see cref="T:SharpDX.DXGI.AdapterDescription"/> structure containing the amount of available graphics memory. 	
            <code> IDXGIDevice * pDXGIDevice;	
            hr = g_pd3dDevice-&gt;QueryInterface(__uuidof(IDXGIDevice), (void **)&amp;pDXGIDevice);	
            IDXGIAdapter * pDXGIAdapter;	
            pDXGIDevice-&gt;GetAdapter(&amp;pDXGIAdapter);	
            DXGI_ADAPTER_DESC adapterDesc;	
            pDXGIAdapter-&gt;GetDesc(&amp;adapterDesc); </code>	
            	
               	
            </remarks>	
            <unmanaged>HRESULT IDXGIAdapter::GetDesc([Out] DXGI_ADAPTER_DESC* pDesc)</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.Device">
            <summary>	
            An IDXGIDevice interface implements a derived class for DXGI objects that produce image data.	
            </summary>	
            <unmanaged>IDXGIDevice</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Device.QueryResourceResidency(SharpDX.ComObject[])">
            <summary>	
            Gets the residency status of an array of resources.	
            </summary>	
            <remarks>	
            The information returned by the pResidencyStatus argument array describes the residency status at the time that the QueryResourceResidency method was called.   Note that the residency status will constantly change. If you call the QueryResourceResidency method during a device removed state, the pResidencyStatus argument will return the DXGI_RESIDENCY_EVICTED_TO_DISK flag. Note??This method should not be called every frame as it incurs a non-trivial amount of overhead. 	
            </remarks>	
            <param name="comObjects">An array of <see cref="T:SharpDX.DXGI.Resource"/> interfaces. </param>
            <returns>Returns an array of <see cref="T:SharpDX.DXGI.Residency"/> flags. Each element describes the residency status for corresponding element in  the ppResources argument array. </returns>
            <unmanaged>HRESULT IDXGIDevice::QueryResourceResidency([In, Buffer] const IUnknown** ppResources,[Out, Buffer] DXGI_RESIDENCY* pResidencyStatus,[None] int NumResources)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Device.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.Device"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.Device.GetAdapter(SharpDX.DXGI.Adapter@)">
            <summary>	
            Returns the adapter for the specified device.	
            </summary>	
            <remarks>	
            If the GetAdapter method succeeds, the reference count on the adapter interface will be incremented. To avoid a memory leak, be sure to release the interface when you are finished using it. 	
            </remarks>	
            <param name="adapterRef">The address of an <see cref="T:SharpDX.DXGI.Adapter"/> interface reference to the adapter.  This parameter must not be NULL. </param>
            <returns>Returns S_OK if successful; otherwise, returns one of the <see cref="T:SharpDX.DXGI.DXGIError"/> that indicates failure. If the pAdapter parameter is NULL this method returns <see cref="F:SharpDX.DXGI.DXGIError.InvalidCall"/>. </returns>
            <unmanaged>HRESULT IDXGIDevice::GetAdapter([Out] IDXGIAdapter** pAdapter)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Device.CreateSurface(SharpDX.DXGI.SurfaceDescription@,System.Int32,SharpDX.DXGI.Usage,System.Nullable{SharpDX.DXGI.SharedResource},SharpDX.DXGI.Surface@)">
            <summary>	
            Returns a surface. This method is used internally and you should not call it directly in your application.	
            </summary>	
            <remarks>	
            The CreateSurface method creates a buffer to exchange data between one or more devices. It is used internally, and you should not directly call it. The runtime automatically creates an <see cref="T:SharpDX.DXGI.Surface"/> interface when it creates a Direct3D resource object that represents a surface. For example, the runtime creates an IDXGISurface interface when it calls <see cref="!:SharpDX.Direct3D11.Device.CreateTexture2D"/> or <see cref="!:SharpDX.Direct3D10.Device.CreateTexture2D"/> to create a 2D texture. To retrieve the IDXGISurface interface that represents the 2D texture surface, call {{ID3D11Texture2D::QueryInterface}} or ID3D10Texture2D::QueryInterface. In this call, you must pass the identifier of IDXGISurface. If the 2D texture has only a single MIP-map level and does not consist of an array of textures, QueryInterface succeeds and returns a reference to the IDXGISurface interface reference. Otherwise, QueryInterface fails and does not return the reference to IDXGISurface. 	
             	
            </remarks>	
            <param name="descRef">A reference to a <see cref="T:SharpDX.DXGI.SurfaceDescription"/> structure that describes the surface. </param>
            <param name="numSurfaces">The number of surfaces to create. </param>
            <param name="usage">A <see cref="T:SharpDX.DXGI.Usage"/> flag that specifies how the surface is expected to be used. </param>
            <param name="sharedResourceRef">An optional reference to a <see cref="T:SharpDX.DXGI.SharedResource"/> structure that contains shared resource information for opening views of such resources. </param>
            <param name="surfaceRef">The address of an <see cref="T:SharpDX.DXGI.Surface"/> interface reference to the first created surface. </param>
            <returns>Returns S_OK if successful; an error code otherwise.  For a list of error codes, see <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIDevice::CreateSurface([In] const DXGI_SURFACE_DESC* pDesc,[None] int NumSurfaces,[None] DXGI_USAGE Usage,[In, Optional] const DXGI_SHARED_RESOURCE* pSharedResource,[Out] IDXGISurface** ppSurface)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Device.QueryResourceResidency(SharpDX.ComObject[],SharpDX.DXGI.Residency[],System.Int32)">
            <summary>	
            Gets the residency status of an array of resources.	
            </summary>	
            <remarks>	
            The information returned by the pResidencyStatus argument array describes the residency status at the time that the QueryResourceResidency method was called.   Note that the residency status will constantly change. If you call the QueryResourceResidency method during a device removed state, the pResidencyStatus argument will return the DXGI_RESIDENCY_EVICTED_TO_DISK flag. Note??This method should not be called every frame as it incurs a non-trivial amount of overhead. 	
            </remarks>	
            <param name="resourcesRef">An array of <see cref="T:SharpDX.DXGI.Resource"/> interfaces. </param>
            <param name="residencyStatusRef">An array of <see cref="T:SharpDX.DXGI.Residency"/> flags. Each element describes the residency status for corresponding element in  the ppResources argument array. </param>
            <param name="numResources">The number of resources in the ppResources argument array and pResidencyStatus argument array. </param>
            <returns>Returns S_OK if successfull; otherwise, returns <see cref="F:SharpDX.DXGI.DXGIError.DeviceRemoved"/>, E_INVALIDARG, or  E_POINTER (see {{WinError.h}} for more information). </returns>
            <unmanaged>HRESULT IDXGIDevice::QueryResourceResidency([In, Buffer] const IUnknown** ppResources,[Out, Buffer] DXGI_RESIDENCY* pResidencyStatus,[None] int NumResources)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Device.SetGPUThreadPriority(System.Int32)">
            <summary>	
            Sets the GPU thread priority.	
            </summary>	
            <remarks>	
            The values for the Priority parameter function as follows:  Positive values increase the likelihood that the GPU scheduler will grant GPU execution cycles to the device when rendering. Negative values lessen the likelihood that the device will receive GPU execution cycles when devices compete for them. The device is guaranteed to receive some GPU execution cycles at all settings.  To use the SetGPUThreadPriority method, you should have a comprehensive understanding of GPU scheduling. You should profile your application to ensure that it behaves as intended. If used inappropriately, the SetGPUThreadPriority method can impede rendering speed and result in a poor user experience. 	
            </remarks>	
            <param name="priority">A value that specifies the required GPU thread priority. This value must be between -7 and 7, inclusive, where 0 represents normal priority. </param>
            <returns>Return S_OK if successful; otherwise, returns E_INVALIDARG if the Priority parameter is invalid. </returns>
            <unmanaged>HRESULT IDXGIDevice::SetGPUThreadPriority([None] int Priority)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Device.GetGPUThreadPriority(System.Int32@)">
            <summary>	
            Gets the GPU thread priority.	
            </summary>	
            <param name="riorityRef">A reference to a variable that receives a value that indicates the current GPU thread priority. The value will be between -7 and 7, inclusive, where 0 represents normal priority. </param>
            <returns>Return S_OK if successful; otherwise, returns E_POINTER if the pPriority parameter is NULL. </returns>
            <unmanaged>HRESULT IDXGIDevice::GetGPUThreadPriority([Out] int* pPriority)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.Device.Adapter">
            <summary>	
            Returns the adapter for the specified device.	
            </summary>	
            <remarks>	
            If the GetAdapter method succeeds, the reference count on the adapter interface will be incremented. To avoid a memory leak, be sure to release the interface when you are finished using it. 	
            </remarks>	
            <unmanaged>HRESULT IDXGIDevice::GetAdapter([Out] IDXGIAdapter** pAdapter)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.Device.GPUThreadPriority">
            <summary>	
            Gets the GPU thread priority.	
            </summary>	
            <unmanaged>HRESULT IDXGIDevice::GetGPUThreadPriority([Out] int* pPriority)</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.DeviceChild">
            <summary>	
            Inherited from objects that are tied to the device so that they can retrieve a reference to it.	
            </summary>	
            <unmanaged>IDXGIDeviceSubObject</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.DeviceChild.GetDevice``1">
            <summary>
            Retrieves the device.
            </summary>
            <typeparam name="T">The interface that is returned can be any interface published by the device.</typeparam>
            <returns>The associated device. </returns>
            <unmanaged>HRESULT IDXGIDeviceSubObject::GetDevice([In] GUID* riid,[Out] void** ppDevice)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.DeviceChild.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.DeviceChild"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.DeviceChild.GetDevice(System.Guid,System.IntPtr@)">
            <summary>	
            Retrieves the device.	
            </summary>	
            <remarks>	
            The type of interface that is returned can be any interface published by the device. For example, it could be an IDXGIDevice * called pDevice, and therefore the REFIID would be obtained by calling __uuidof(pDevice). 	
            </remarks>	
            <param name="riid">The reference id for the device. </param>
            <param name="deviceRef">The address of a reference to the device. </param>
            <returns>A code that indicates success or failure (see <see cref="T:SharpDX.DXGI.DXGIError"/>). </returns>
            <unmanaged>HRESULT IDXGIDeviceSubObject::GetDevice([In] GUID* riid,[Out] void** ppDevice)</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.Factory">
            <summary>	
            An IDXGIFactory interface implements methods for generating DXGI objects (which handle fullscreen transitions).	
            </summary>	
            <unmanaged>IDXGIFactory</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Factory.#ctor">
            <summary>
              Default Constructor for Factory
            </summary>
        </member>
        <member name="M:SharpDX.DXGI.Factory.CreateSoftwareAdapter(System.Reflection.Module)">
            <summary>	
            Create an adapter interface that represents a software adapter.	
            </summary>	
            <remarks>	
            A software adapter is a DLL that implements the entirety of a device driver interface, plus emulation, if necessary, of kernel-mode graphics components for Windows. Details on implementing a software adapter can be found in the Windows Vista Driver Development Kit. This is a very complex development task, and is not recommended for general readers. Calling this method will increment the module's reference count by one. The reference count can be decremented by calling {{FreeLibrary}}. The typical calling scenario is to call {{LoadLibrary}}, pass the handle to CreateSoftwareAdapter, then immediately call {{FreeLibrary}} on the DLL and forget the DLL's {{HMODULE}}. Since the software adapter calls FreeLibrary when it is destroyed, the lifetime of the DLL will now be owned by the adapter, and the application is free of any further consideration of its lifetime. 	
            </remarks>	
            <param name="module">Handle to the software adapter's dll.</param>
            <returns>A reference to an adapter (see <see cref="T:SharpDX.DXGI.Adapter" />). </returns>
            <unmanaged>HRESULT IDXGIFactory::CreateSoftwareAdapter([None] void* Module,[Out] IDXGIAdapter** ppAdapter)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Factory.GetAdapterCount">
            <summary>
              Return the number of available adapters from this factory.
            </summary>
            <returns>The number of adapters</returns>
        </member>
        <member name="M:SharpDX.DXGI.Factory.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.Factory"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.Factory.GetAdapter(System.Int32)">
            <summary>	
            Enumerates the adapters (video cards).	
            </summary>	
            <remarks>	
            The set of adapters available in the system is enumerated when the factory is created. Therefore, if you change the adapters in a system, you must destroy and recreate the <see cref="T:SharpDX.DXGI.Factory"/> object. The number of adapters adapters in a system changes when you add or remove a display card, or dock or undock a laptop. When the EnumAdapters method succeeds and the adapter interface is filled, the adapters reference count will be incremented. When you are finished with the adapter interface, be sure to call the Release method to decrement the reference count before you destroy the reference. 	
            </remarks>	
            <param name="adapter">The index of the adapter to enumerate. </param>
            <returns>The address of a reference to as <see cref="T:SharpDX.DXGI.Adapter"/> interface at the position specified by the Adapter parameter.  This parameter must not be NULL. </returns>
            <unmanaged>HRESULT IDXGIFactory::EnumAdapters([None] int Adapter,[Out] IDXGIAdapter** ppAdapter)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Factory.MakeWindowAssociation(System.IntPtr,SharpDX.DXGI.WindowAssociationFlags)">
            <summary>	
            Allows DXGI to monitor an application's message queue for the alt-enter key sequence (which causes the application to switch from windowed to fullscreen or vice versa).	
            </summary>	
            <remarks>	
            The combination of WindowHandle and Flags informs DXGI to stop monitoring window messages for the previously-associated window. If the application switches to full-screen mode, DXGI will choose a full-screen resolution to be the smallest supported resolution that is larger or the same size as the current back buffer size. Applications can make some changes to make the transition from windowed to full screen more efficient. For example, on a WM_SIZE message, the application should release any outstanding swap-chain back buffers, call <see cref="M:SharpDX.DXGI.SwapChain.ResizeBuffers(System.Int32,System.Int32,System.Int32,SharpDX.DXGI.Format,System.Int32)"/>, then re-acquire the back buffers from the swap chain(s). This gives the swap chain(s) an opportunity to resize the back buffers, and/or recreate them to enable full-screen flipping operation. If the application does not perform this sequence, DXGI will still make the full-screen/windowed transition, but may be forced to use a stretch operation (since the back buffers may not be the correct size), which may be less efficient. Even if a stretch is not required, presentation may not be optimal because the back buffers might not be directly interchangeable with the front buffer. Thus, a call to ResizeBuffers on WM_SIZE is always recommended, since WM_SIZE is always sent during a fullscreen transition. While windowed, the application can, if it chooses, restrict the size of its window's client area to sizes to which it is comfortable rendering. A fully flexible application would make no such restriction, but UI elements or other design considerations can, of course, make this flexibility untenable. If the application further chooses to restrict its window's client area to just those that match supported full-screen resolutions, the application can field WM_SIZING, then check against <see cref="M:SharpDX.DXGI.Output.FindClosestMatchingMode(SharpDX.DXGI.ModeDescription@,SharpDX.DXGI.ModeDescription@,SharpDX.ComObject)"/>. If a matching mode is found, allow the resize. (The IDXGIOutput can be retrieved from <see cref="M:SharpDX.DXGI.SwapChain.GetContainingOutput(SharpDX.DXGI.Output@)"/>. Absent subsequent changes to desktop topology, this will be the same output that will be chosen when alt-enter is fielded and fullscreen mode is begun for that swap chain.) Applications that want to handle mode changes or Alt+Enter themselves should call MakeWindowAssociation with the DXGI_MWA_NO_WINDOW_CHANGES flag after swap chain creation. The WindowHandle argument, if non-NULL, specifies that the application message queues will not be handled by the DXGI runtime for all swap chains of a particular target {{HWND}}.  Calling MakeWindowAssociation with the DXGI_MWA_NO_WINDOW_CHANGES flag after swapchain creation ensures that DXGI will not interfere with application's handling of window mode changes or Alt+Enter. 	
            </remarks>	
            <param name="windowHandle">The handle of the window that is to be monitored. This parameter can be NULL; but only if the flags are also 0.  </param>
            <param name="flags">One or more of the following values:  DXGI_MWA_NO_WINDOW_CHANGES - Prevent DXGI from monitoring an applications message queue; this makes DXGI unable to respond to mode changes. DXGI_MWA_NO_ALT_ENTER - Prevent DXGI from responding to an alt-enter sequence. DXGI_MWA_NO_PRINT_SCREEN - Prevent DXGI from responding to a print-screen key.  </param>
            <returns><see cref="F:SharpDX.DXGI.DXGIError.InvalidCall"/> if WindowHandle is invalid, or E_OUTOFMEMORY. </returns>
            <unmanaged>HRESULT IDXGIFactory::MakeWindowAssociation([None] void* WindowHandle,[None] DXGI_MWA_FLAGS Flags)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Factory.GetWindowAssociation">
            <summary>	
            Get the window through which the user controls the transition to and from fullscreen.	
            </summary>	
            <returns>A reference to a window handle. </returns>
            <unmanaged>HRESULT IDXGIFactory::GetWindowAssociation([Out] void** pWindowHandle)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Factory.CreateSwapChain(SharpDX.ComObject,SharpDX.DXGI.SwapChainDescription@,SharpDX.DXGI.SwapChain@)">
            <summary>	
            Creates a swap chain.	
            </summary>	
            <remarks>	
            If you attempt to create a swap chain in full-screen mode, and full-screen mode is unavailable, the swap chain will be created in windowed mode and DXGI_STATUS_OCCLUDED will be returned. If the buffer width or the buffer height are zero, the sizes will be inferred from the output window size in the swap-chain description. Since the target output cannot be chosen explicitly when the swap-chain is created, you should not create a full-screen swap chain. This can reduce presentation performance if the swap chain size and the output window size do not match. Here are two ways to ensure the sizes match:  Create a windowed swap chain and then set it full-screen using <see cref="M:SharpDX.DXGI.SwapChain.SetFullscreenState(System.Boolean,SharpDX.DXGI.Output)"/>. Save a reference to the swap-chain immediately after creation, and use it to get the output window size during a WM_SIZE event. Then resize the swap chain buffers (with <see cref="M:SharpDX.DXGI.SwapChain.ResizeBuffers(System.Int32,System.Int32,System.Int32,SharpDX.DXGI.Format,System.Int32)"/>) during the transition from windowed to full-screen.  If the swap chain is in full-screen mode, before you release it, you must use {{SetFullscreenState}} to switch it to windowed mode. For more information about releasing a swap chain, see the Destroying a Swap Chain section of {{DXGI Overview}}. 	
            </remarks>	
            <param name="deviceRef">A reference to the device that will write 2D images to the swap chain. </param>
            <param name="descRef">A reference to the swap-chain description (see <see cref="T:SharpDX.DXGI.SwapChainDescription"/>). This parameter cannot be NULL. </param>
            <param name="swapChainRef">A reference to the swap chain created (see <see cref="T:SharpDX.DXGI.SwapChain"/>). </param>
            <returns><see cref="F:SharpDX.DXGI.DXGIError.InvalidCall"/> if pDesc or ppSwapChain is NULL, DXGI_STATUS_OCCLUDED if you request full-screen mode and it is unavailable, or E_OUTOFMEMORY. Other error codes defined by the type of device passed in may also be returned. </returns>
            <unmanaged>HRESULT IDXGIFactory::CreateSwapChain([In] IUnknown* pDevice,[In] DXGI_SWAP_CHAIN_DESC* pDesc,[Out] IDXGISwapChain** ppSwapChain)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Factory.CreateSoftwareAdapter(System.IntPtr)">
            <summary>	
            Create an adapter interface that represents a software adapter.	
            </summary>	
            <remarks>	
            A software adapter is a DLL that implements the entirety of a device driver interface, plus emulation, if necessary, of kernel-mode graphics components for Windows. Details on implementing a software adapter can be found in the Windows Vista Driver Development Kit. This is a very complex development task, and is not recommended for general readers. Calling this method will increment the module's reference count by one. The reference count can be decremented by calling {{FreeLibrary}}. The typical calling scenario is to call {{LoadLibrary}}, pass the handle to CreateSoftwareAdapter, then immediately call {{FreeLibrary}} on the DLL and forget the DLL's {{HMODULE}}. Since the software adapter calls FreeLibrary when it is destroyed, the lifetime of the DLL will now be owned by the adapter, and the application is free of any further consideration of its lifetime. 	
            </remarks>	
            <param name="module">Handle to the software adapter's dll. HMODULE can be obtained with {{GetModuleHandle}} or {{LoadLibrary}}. </param>
            <returns>Address of a reference to an adapter (see <see cref="T:SharpDX.DXGI.Adapter"/>). </returns>
            <unmanaged>HRESULT IDXGIFactory::CreateSoftwareAdapter([None] void* Module,[Out] IDXGIAdapter** ppAdapter)</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.Factory1">
            <summary>	
            The IDXGIFactory1 interface implements methods for generating DXGI objects.	
            </summary>	
            <unmanaged>IDXGIFactory1</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Factory1.#ctor">
            <summary>
              Default Constructor for Factory1.
            </summary>
        </member>
        <member name="M:SharpDX.DXGI.Factory1.GetAdapterCount1">
            <summary>
              Return the number of available adapters from this factory.
            </summary>
            <returns>The number of adapters</returns>
        </member>
        <member name="M:SharpDX.DXGI.Factory1.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.Factory1"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.Factory1.GetAdapter1(System.Int32)">
            <summary>	
            Enumerates both adapters (video cards) with or without outputs.	
            </summary>	
            <remarks>	
            The set of adapters available in the system is enumerated when the factory is created. Therefore, if you change the adapters in a system, you must destroy  and recreate the <see cref="T:SharpDX.DXGI.Factory1"/> object. The number of adapters adapters in a system changes when you add or remove a display card, or dock or undock a laptop.  When the EnumAdapters1 method succeeds and the adapter interface is filled, the adapters reference count will be incremented. When you are finished with the  adapter interface, be sure to call the Release method to decrement the reference count before you destroy the reference. The local adapter with output on which the Desktop primary is displayed is returned first, followed by other adapter(s) with outputs, then adapter(s) without outputs. 	
            </remarks>	
            <param name="adapter">The index of the adapter to enumerate. </param>
            <returns>The address of a reference to as <see cref="T:SharpDX.DXGI.Adapter1"/> interface at the position specified by the Adapter parameter.   This parameter must not be NULL. </returns>
            <unmanaged>HRESULT IDXGIFactory1::EnumAdapters1([None] int Adapter,[Out] IDXGIAdapter1** ppAdapter)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Factory1.IsCurrent_">
            <summary>	
            Informs an application of the possible need to re-enumerate adapters.	
            </summary>	
            <returns>FALSE, if a new adapter is becoming available or the current adapter is going away. TRUE, no adapter changes. IsCurrent returns FALSE to inform the calling application to re-enumerate adapters. </returns>
            <unmanaged>BOOL IDXGIFactory1::IsCurrent()</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.Factory1.IsCurrent">
            <summary>	
            Informs an application of the possible need to re-enumerate adapters.	
            </summary>	
            <unmanaged>BOOL IDXGIFactory1::IsCurrent()</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.FormatHelper">
            <summary>
            Helper to use with <see cref="T:SharpDX.DXGI.Format"/>.
            </summary>
        </member>
        <member name="M:SharpDX.DXGI.FormatHelper.SizeOfInBytes(SharpDX.DXGI.Format)">
            <summary>
            Calculates the size of a <see cref="T:SharpDX.DXGI.Format"/> in bytes.
            </summary>
            <param name="format">The dxgi format.</param>
            <returns>size of in bytes</returns>
        </member>
        <member name="M:SharpDX.DXGI.FormatHelper.SizeOfInBits(SharpDX.DXGI.Format)">
            <summary>
            Calculates the size of a <see cref="T:SharpDX.DXGI.Format"/> in bits.
            </summary>
            <param name="format">The dxgi format.</param>
            <returns>size of in bits</returns>
        </member>
        <member name="T:SharpDX.DXGI.Residency">
            <summary>	
            Flags indicating the memory location of a resource.	
            </summary>	
            <unmanaged>DXGI_RESIDENCY</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Residency.FullyResident">
            <summary>	
            The resource is located in video memory. 	
            </summary>	
            <unmanaged>DXGI_RESIDENCY_FULLY_RESIDENT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Residency.ResidentInSharedMemory">
            <summary>	
            At least some of the resource is located in CPU memory. 	
            </summary>	
            <unmanaged>DXGI_RESIDENCY_RESIDENT_IN_SHARED_MEMORY</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Residency.EvictedToDisk">
            <summary>	
            At least some of the resource has been paged out to the hard drive. 	
            </summary>	
            <unmanaged>DXGI_RESIDENCY_EVICTED_TO_DISK</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.SwapEffect">
            <summary>	
            Options for handling pixels in a display surface after calling <see cref="M:SharpDX.DXGI.SwapChain.Present(System.Int32,SharpDX.DXGI.PresentFlags)"/>.	
            </summary>	
            <remarks>	
            This enumeration is used by the <see cref="T:SharpDX.DXGI.SwapChainDescription"/> structure. 	
            </remarks>	
            <unmanaged>DXGI_SWAP_EFFECT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SwapEffect.Discard">
            <summary>	
            Use this flag to indicate that the contents of the back buffer are discarded after calling IDXGISwapChain::Present.  This flag is valid for a swap chain with more than one back buffer, although, an application only has read and write access to buffer 0.  Use this flag to enable the display driver to select the most efficient presentation technique for the swap chain. 	
            </summary>	
            <unmanaged>DXGI_SWAP_EFFECT_DISCARD</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SwapEffect.Sequential">
            <summary>	
            Use this flag to indicate that the contents of the back buffer are not discarded after calling IDXGISwapChain::Present.  Use this option to present the contents of the swap chain in order, from the first buffer (buffer 0) to the last buffer.  This flag cannot be used with multisampling. 	
            </summary>	
            <unmanaged>DXGI_SWAP_EFFECT_SEQUENTIAL</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.SwapChainFlags">
            <summary>	
            Options for swap-chain behavior.	
            </summary>	
            <remarks>	
            This enumeration is used by the <see cref="T:SharpDX.DXGI.SwapChainDescription"/> structure. 	
            </remarks>	
            <unmanaged>DXGI_SWAP_CHAIN_FLAG</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SwapChainFlags.Nonprerotated">
            <summary>	
            Turn off automatic image rotation; that is, do not perform a rotation when transfering the contents of the front buffer to the monitor.  Use this flag to avoid a bandwidth penalty when an application expects to handle rotation. This option is only valid during full-screen mode.  	
            </summary>	
            <unmanaged>DXGI_SWAP_CHAIN_FLAG_NONPREROTATED</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SwapChainFlags.AllowModeSwitch">
            <summary>	
            Set this flag to enable an application to switch modes by calling <see cref="M:SharpDX.DXGI.SwapChain.ResizeTarget(SharpDX.DXGI.ModeDescription@)"/>.  When switching from windowed to full-screen mode, the display mode (or monitor resolution) will be changed to match the dimensions of the application window. 	
            </summary>	
            <unmanaged>DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SwapChainFlags.GdiCompatible">
            <summary>	
            Set this flag to enable an application to render using GDI on a swap chain or a surface.  This will allow the application to call GetDC on the 0th back buffer or a surface. 	
            </summary>	
            <unmanaged>DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SwapChainFlags.None">
            <summary>	
            None.	
            </summary>	
            <unmanaged>None</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.AdapterFlags">
            <summary>	
            Identifies the type of DXGI adapter.	
            </summary>	
            <remarks>	
            The DXGI_ADAPTER_FLAG enumerated type is used by the Flags member of the <see cref="T:SharpDX.DXGI.AdapterDescription1"/> structure to  identify the type of DXGI adapter. 	
            </remarks>	
            <unmanaged>DXGI_ADAPTER_FLAG</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterFlags.None">
            <summary>	
            Specifies no flags. 	
            </summary>	
            <unmanaged>DXGI_ADAPTER_FLAG_NONE</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterFlags.Remote">
            <summary>	
            Value always set to 0. This flag is reserved. 	
            </summary>	
            <unmanaged>DXGI_ADAPTER_FLAG_REMOTE</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.PresentFlags">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_PRESENT_FLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.PresentFlags.Test">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_PRESENT_TEST</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.PresentFlags.DoNotSequence">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_PRESENT_DO_NOT_SEQUENCE</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.PresentFlags.Restart">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_PRESENT_RESTART</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.PresentFlags.None">
            <summary>	
            None.	
            </summary>	
            <unmanaged>None</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.ResourcePriority">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_RESOURCE_PRIORITY</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.ResourcePriority.Minimum">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_RESOURCE_PRIORITY_MINIMUM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.ResourcePriority.Low">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_RESOURCE_PRIORITY_LOW</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.ResourcePriority.Normal">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_RESOURCE_PRIORITY_NORMAL</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.ResourcePriority.High">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_RESOURCE_PRIORITY_HIGH</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.ResourcePriority.Maximum">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_RESOURCE_PRIORITY_MAXIMUM</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.MapFlags">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_MAP_FLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.MapFlags.Read">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_MAP_READ</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.MapFlags.Write">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_MAP_WRITE</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.MapFlags.Discard">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_MAP_DISCARD</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.DisplayModeEnumerationFlags">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ENUM_MODES_FLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeEnumerationFlags.Interlaced">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ENUM_MODES_INTERLACED</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeEnumerationFlags.Scaling">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ENUM_MODES_SCALING</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.WindowAssociationFlags">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_MWA_FLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.WindowAssociationFlags.IgnoreAll">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_MWA_NO_WINDOW_CHANGES</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.WindowAssociationFlags.IgnoreAltEnter">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_MWA_NO_ALT_ENTER</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.WindowAssociationFlags.IgnorePrintScreen">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_MWA_NO_PRINT_SCREEN</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.WindowAssociationFlags.Valid">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_MWA_VALID</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.WindowAssociationFlags.None">
            <summary>	
            None.	
            </summary>	
            <unmanaged>None</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.DisplayModeScanlineOrder">
            <summary>	
            Flags indicating the method the raster uses to create an image on a surface.	
            </summary>	
            <unmanaged>DXGI_MODE_SCANLINE_ORDER</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeScanlineOrder.Unspecified">
            <summary>	
            Scanline order is unspecified. 	
            </summary>	
            <unmanaged>DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeScanlineOrder.Progressive">
            <summary>	
            The image is created from the first scanline to the last without skipping any. 	
            </summary>	
            <unmanaged>DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeScanlineOrder.UpperFieldFirst">
            <summary>	
            The image is created beginning with the upper field. 	
            </summary>	
            <unmanaged>DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeScanlineOrder.LowerFieldFirst">
            <summary>	
            The image is created beginning with the lower field. 	
            </summary>	
            <unmanaged>DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.DisplayModeScaling">
            <summary>	
            Flags indicating how an image is stretched to fit a given monitor's resolution.	
            </summary>	
            <unmanaged>DXGI_MODE_SCALING</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeScaling.Unspecified">
            <summary>	
            Unspecified scaling. 	
            </summary>	
            <unmanaged>DXGI_MODE_SCALING_UNSPECIFIED</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeScaling.Centered">
            <summary>	
            Specifies no scaling. The image is centered on the display. This flag is typically used for a fixed-dot-pitch display (such as an LED display). 	
            </summary>	
            <unmanaged>DXGI_MODE_SCALING_CENTERED</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeScaling.Stretched">
            <summary>	
            Specifies stretched scaling. 	
            </summary>	
            <unmanaged>DXGI_MODE_SCALING_STRETCHED</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.DisplayModeRotation">
            <summary>	
            Flags that indicate how the back buffers should be rotated to fit the physical rotation of a monitor.	
            </summary>	
            <unmanaged>DXGI_MODE_ROTATION</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeRotation.Unspecified">
            <summary>	
            Unspecified rotation. 	
            </summary>	
            <unmanaged>DXGI_MODE_ROTATION_UNSPECIFIED</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeRotation.Identity">
            <summary>	
            Specifies no rotation. 	
            </summary>	
            <unmanaged>DXGI_MODE_ROTATION_IDENTITY</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeRotation.Rotate90">
            <summary>	
            Specifies 90 degrees of rotation. 	
            </summary>	
            <unmanaged>DXGI_MODE_ROTATION_ROTATE90</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeRotation.Rotate180">
            <summary>	
            Specifies 180 degrees of rotation. 	
            </summary>	
            <unmanaged>DXGI_MODE_ROTATION_ROTATE180</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DisplayModeRotation.Rotate270">
            <summary>	
            Specifies 270 degrees of rotation. 	
            </summary>	
            <unmanaged>DXGI_MODE_ROTATION_ROTATE270</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.Usage">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_USAGE</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Usage.ShaderInput">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_USAGE_SHADER_INPUT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Usage.RenderTargetOutput">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_USAGE_RENDER_TARGET_OUTPUT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Usage.BackBuffer">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_USAGE_BACK_BUFFER</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Usage.Shared">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_USAGE_SHARED</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Usage.ReadOnly">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_USAGE_READ_ONLY</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Usage.DiscardOnPresent">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_USAGE_DISCARD_ON_PRESENT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Usage.UnorderedAccess">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_USAGE_UNORDERED_ACCESS</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.DXGIError">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.InvalidCall">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_INVALID_CALL</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.NotFound">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_NOT_FOUND</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.MoreData">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_MORE_DATA</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.Unsupported">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_UNSUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.DeviceRemoved">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_DEVICE_REMOVED</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.DeviceHung">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_DEVICE_HUNG</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.DeviceReset">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_DEVICE_RESET</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.WasStillDrawing">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_WAS_STILL_DRAWING</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.FrameStatisticsDisjoint">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_FRAME_STATISTICS_DISJOINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.GraphicsVidpnSourceInUse">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.DriverInternalError">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_DRIVER_INTERNAL_ERROR</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.Nonexclusive">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_NONEXCLUSIVE</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.NotCurrentlyAvailable">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_NOT_CURRENTLY_AVAILABLE</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.RemoteClientDisconnected">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIError.RemoteOutofmemory">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_ERROR_REMOTE_OUTOFMEMORY</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.DXGIStatus">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_STATUS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIStatus.Occluded">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_STATUS_OCCLUDED</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIStatus.Clipped">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_STATUS_CLIPPED</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIStatus.NoRedirection">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_STATUS_NO_REDIRECTION</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIStatus.NoDesktopAccess">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_STATUS_NO_DESKTOP_ACCESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIStatus.GraphicsVidpnSourceInUse">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIStatus.ModeChanged">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_STATUS_MODE_CHANGED</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.DXGIStatus.ModeChangeInProgress">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>DXGI_STATUS_MODE_CHANGE_IN_PROGRESS</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.Format">
            <summary>	
            Resource data formats which includes fully-typed and typeless formats. There is a list of format modifiers at the bottom of the page,  that more fully describes each format type.	
            </summary>	
            <remarks>	
            A few formats have additional restrictions.  A resource declared with the DXGI_FORMAT_R32G32B32 family of formats cannot be used simultaneously for vertex and texture data. That is, you may not create a buffer resource with the DXGI_FORMAT_R32G32B32 family of formats that uses any of the following bind flags: D3D10_BIND_VERTEX_BUFFER, D3D10_BIND_INDEX_BUFFER, D3D10_BIND_CONSTANT_BUFFER, or D3D10_BIND_STREAM_OUTPUT (see <see cref="!:SharpDX.Direct3D10.BindFlags"/>). DXGI_FORMAT_R1_UNORM is designed specifically for text filtering, and must be used with a format-specific, configurable 8x8 filter mode. When calling an HLSL sampling function using this format, the address offset parameter must be set to (0,0). A resource using a sub-sampled format (such as DXGI_FORMAT_R8G8_B8G8) must have a size that is a multiple of 2 in the x dimension. Format is not available in Direct3D 10 and Direct3D 10.1  Format Modifiers Each enumeration value contains a format modifier which describes the data type.  Format ModifiersDescription _FLOATA floating-point value; 32-bit floating-point formats use IEEE 754 single-precision (s23e8 format): sign bit, 8-bit biased (127) exponent,  and 23-bit mantissa. 16-bit floating-point formats use half-precision (s10e5 format): sign bit, 5-bit biased (15) exponent, and 10-bit mantissa. _SINTTwo's complement signed integer. For example, a 3-bit SINT represents the values -4, -3, -2, -1, 0, 1, 2, 3. _SNORMSigned normalized integer; which is interpreted in a resource as a signed integer, and is interpreted in a shader as a signed normalized floating-point value in the range [-1, 1]. For an 2's complement number, the maximum value is 1.0f (a 5-bit value 01111 maps to 1.0f), and the minimum value is -1.0f (a 5-bit value 10000 maps to -1.0f). In addition, the second-minimum number maps to -1.0f (a 5-bit value 10001 maps to -1.0f). The resulting integer representations are evenly spaced floating-point values in the range (-1.0f...0.0f), and also a complementary set of representations for numbers in the range (0.0f...1.0f). _SRGBStandard RGB data, which roughly displays colors in a linear ramp of luminosity levels such that an average observer, under average viewing conditions, can view them on an average display.  All 0's maps to 0.0f, and all 1's maps to 1.0f. The sequence of unsigned integer encodings between all 0's and all 1's represent a nonlinear progression in the floating-point interpretation of the numbers between 0.0f to 1.0f. For more detail, see the SRGB color standard, IEC 61996-2-1, at IEC (International Electrotechnical Commission). Conversion to or from sRGB space is automatically done by D3DX10 or D3DX9 texture-load functions. If the format has an alpha channel, the alpha data is also stored in sRGB color space.  _TYPELESSTypeless data, with a defined number of bits. Typeless formats are designed for creating typeless resources; that is, a resource whose size is known, but whose data type is not yet fully defined. When a typeless resource is bound to a shader, the application or shader must resolve the format type (which must match the number of bits per component in the typeless format). A typeless format contains one or more subformats; each subformat resolves the data type. For example, in the R32G32B32 group, which defines types for three-component 96-bit data, there is one typeless format and three fully typed subformats. 	
            <code> DXGI_FORMAT_R32G32B32_TYPELESS, DXGI_FORMAT_R32G32B32_FLOAT, DXGI_FORMAT_R32G32B32_UINT, DXGI_FORMAT_R32G32B32_SINT, </code>	
            	
              _UINTUnsigned integer. For instance, a 3-bit UINT represents the values 0, 1, 2, 3, 4, 5, 6, 7. _UNORMUnsigned normalized integer; which is interpreted in a resource as an unsigned integer, and is interpreted in a shader as an unsigned normalized floating-point value in the range [0, 1]. All 0's maps to 0.0f, and all 1's maps to 1.0f. A sequence of evenly spaced floating-point values from 0.0f to 1.0f are represented. For instance, a 2-bit UNORM represents 0.0f, 1/3, 2/3, and 1.0f.  ? New Resource Formats Direct3D 10 offers new data compression formats for compressing high-dynamic range (HDR) lighting data, normal maps and heightfields to a fraction of their original size. These compression types include:  Shared-Exponent high-dynamic range (HDR) format (RGBE) New Block-Compressed 1-2 channel UNORM/SNORM formats  The block compression formats can be used for any of the 2D or 3D texture types ( Texture2D, Texture2DArray, Texture3D, or TextureCube) including mipmap surfaces. The block compression techniques require texture dimensions to be a multiple of 4 (since the implementation compresses on blocks of 4x4 texels). In the texture sampler, compressed formats are always decompressed before texture filtering. 	
            </remarks>	
            <unmanaged>DXGI_FORMAT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.Unknown">
            <summary>	
            The format is not known. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_UNKNOWN</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32G32B32A32_Typeless">
            <summary>	
            A four-component, 128-bit typeless format. 1 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32G32B32A32_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32G32B32A32_Float">
            <summary>	
            A four-component, 128-bit floating-point format. 1 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32G32B32A32_FLOAT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32G32B32A32_UInt">
            <summary>	
            A four-component, 128-bit unsigned-integer format. 1 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32G32B32A32_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32G32B32A32_SInt">
            <summary>	
            A four-component, 128-bit signed-integer format. 1 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32G32B32A32_SINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32G32B32_Typeless">
            <summary>	
            A three-component, 96-bit typeless format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32G32B32_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32G32B32_Float">
            <summary>	
            A three-component, 96-bit floating-point format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32G32B32_FLOAT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32G32B32_UInt">
            <summary>	
            A three-component, 96-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32G32B32_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32G32B32_SInt">
            <summary>	
            A three-component, 96-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32G32B32_SINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16G16B16A16_Typeless">
            <summary>	
            A four-component, 64-bit typeless format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16G16B16A16_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16G16B16A16_Float">
            <summary>	
            A four-component, 64-bit floating-point format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16G16B16A16_FLOAT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16G16B16A16_UNorm">
            <summary>	
            A four-component, 64-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16G16B16A16_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16G16B16A16_UInt">
            <summary>	
            A four-component, 64-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16G16B16A16_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16G16B16A16_SNorm">
            <summary>	
            A four-component, 64-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16G16B16A16_SNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16G16B16A16_SInt">
            <summary>	
            A four-component, 64-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16G16B16A16_SINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32G32_Typeless">
            <summary>	
            A two-component, 64-bit typeless format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32G32_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32G32_Float">
            <summary>	
            A two-component, 64-bit floating-point format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32G32_FLOAT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32G32_UInt">
            <summary>	
            A two-component, 64-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32G32_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32G32_SInt">
            <summary>	
            A two-component, 64-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32G32_SINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32G8X24_Typeless">
            <summary>	
            A two-component, 64-bit typeless format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32G8X24_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.D32_Float_S8X24_UInt">
            <summary>	
            A 32-bit floating-point component, and two unsigned-integer components (with an additional 32 bits). 	
            </summary>	
            <unmanaged>DXGI_FORMAT_D32_FLOAT_S8X24_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32_Float_X8X24_Typeless">
            <summary>	
            A 32-bit floating-point component, and two typeless components (with an additional 32 bits). 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.X32_Typeless_G8X24_UInt">
            <summary>	
            A 32-bit typeless component, and two unsigned-integer components (with an additional 32 bits). 	
            </summary>	
            <unmanaged>DXGI_FORMAT_X32_TYPELESS_G8X24_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R10G10B10A2_Typeless">
            <summary>	
            A four-component, 32-bit typeless format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R10G10B10A2_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R10G10B10A2_UNorm">
            <summary>	
            A four-component, 32-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R10G10B10A2_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R10G10B10A2_UInt">
            <summary>	
            A four-component, 32-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R10G10B10A2_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R11G11B10_Float">
            <summary>	
            Three partial-precision floating-point numbers encodeded into a single 32-bit value (a variant of s10e5).  There are no sign bits, and there is a 5-bit biased (15) exponent for each channel, 6-bit mantissa  for R and G, and a 5-bit mantissa for B, as shown in the following illustration.    	
            </summary>	
            <unmanaged>DXGI_FORMAT_R11G11B10_FLOAT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8G8B8A8_Typeless">
            <summary>	
            A three-component, 32-bit typeless format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8G8B8A8_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8G8B8A8_UNorm">
            <summary>	
            A four-component, 32-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8G8B8A8_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8G8B8A8_UNorm_SRgb">
            <summary>	
            A four-component, 32-bit unsigned-normalized integer sRGB format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8G8B8A8_UInt">
            <summary>	
            A four-component, 32-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8G8B8A8_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8G8B8A8_SNorm">
            <summary>	
            A three-component, 32-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8G8B8A8_SNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8G8B8A8_SInt">
            <summary>	
            A three-component, 32-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8G8B8A8_SINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16G16_Typeless">
            <summary>	
            A two-component, 32-bit typeless format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16G16_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16G16_Float">
            <summary>	
            A two-component, 32-bit floating-point format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16G16_FLOAT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16G16_UNorm">
            <summary>	
            A two-component, 32-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16G16_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16G16_UInt">
            <summary>	
            A two-component, 32-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16G16_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16G16_SNorm">
            <summary>	
            A two-component, 32-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16G16_SNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16G16_SInt">
            <summary>	
            A two-component, 32-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16G16_SINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32_Typeless">
            <summary>	
            A single-component, 32-bit typeless format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.D32_Float">
            <summary>	
            A single-component, 32-bit floating-point format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_D32_FLOAT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32_Float">
            <summary>	
            A single-component, 32-bit floating-point format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32_FLOAT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32_UInt">
            <summary>	
            A single-component, 32-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R32_SInt">
            <summary>	
            A single-component, 32-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R32_SINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R24G8_Typeless">
            <summary>	
            A two-component, 32-bit typeless format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R24G8_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.D24_UNorm_S8_UInt">
            <summary>	
            A 32-bit z-buffer format that uses 24 bits for the depth channel and 8 bits for the stencil channel. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_D24_UNORM_S8_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R24_UNorm_X8_Typeless">
            <summary>	
            A 32-bit format, that contains a 24 bit, single-component, unsigned-normalized integer, with an additional typeless 8 bits. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R24_UNORM_X8_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.X24_Typeless_G8_UInt">
            <summary>	
            A 32-bit format, that contains a 24 bit, single-component, typeless format,  with an additional 8 bit unsigned integer component. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_X24_TYPELESS_G8_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8G8_Typeless">
            <summary>	
            A two-component, 16-bit typeless format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8G8_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8G8_UNorm">
            <summary>	
            A two-component, 16-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8G8_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8G8_UInt">
            <summary>	
            A two-component, 16-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8G8_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8G8_SNorm">
            <summary>	
            A two-component, 16-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8G8_SNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8G8_SInt">
            <summary>	
            A two-component, 16-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8G8_SINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16_Typeless">
            <summary>	
            A single-component, 16-bit typeless format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16_Float">
            <summary>	
            A single-component, 16-bit floating-point format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16_FLOAT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.D16_UNorm">
            <summary>	
            A single-component, 16-bit unsigned-normalized integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_D16_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16_UNorm">
            <summary>	
            A single-component, 16-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16_UInt">
            <summary>	
            A single-component, 16-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16_SNorm">
            <summary>	
            A single-component, 16-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16_SNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R16_SInt">
            <summary>	
            A single-component, 16-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R16_SINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8_Typeless">
            <summary>	
            A single-component, 8-bit typeless format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8_UNorm">
            <summary>	
            A single-component, 8-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8_UInt">
            <summary>	
            A single-component, 8-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8_UINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8_SNorm">
            <summary>	
            A single-component, 8-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8_SNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8_SInt">
            <summary>	
            A single-component, 8-bit signed-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8_SINT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.A8_UNorm">
            <summary>	
            A single-component, 8-bit unsigned-integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_A8_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R1_UNorm">
            <summary>	
            A single-component, 1-bit unsigned-normalized integer format. 2. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R1_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R9G9B9E5_Sharedexp">
            <summary>	
            Three partial-precision floating-point numbers encoded into a single 32-bit value all sharing the same 5-bit exponent (variant of s10e5).  There is no sign bit, and there is a shared 5-bit biased (15) exponent and a 9-bit mantissa for each channel, as shown in the following illustration. 2.    	
            </summary>	
            <unmanaged>DXGI_FORMAT_R9G9B9E5_SHAREDEXP</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R8G8_B8G8_UNorm">
            <summary>	
            A four-component, 32-bit unsigned-normalized integer format. 3 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R8G8_B8G8_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.G8R8_G8B8_UNorm">
            <summary>	
            A four-component, 32-bit unsigned-normalized integer format. 3 	
            </summary>	
            <unmanaged>DXGI_FORMAT_G8R8_G8B8_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC1_Typeless">
            <summary>	
            Four-component typeless block-compression format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC1_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC1_UNorm">
            <summary>	
            Four-component block-compression format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC1_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC1_UNorm_SRgb">
            <summary>	
            Four-component block-compression format for sRGB data. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC1_UNORM_SRGB</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC2_Typeless">
            <summary>	
            Four-component typeless block-compression format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC2_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC2_UNorm">
            <summary>	
            Four-component block-compression format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC2_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC2_UNorm_SRgb">
            <summary>	
            Four-component block-compression format for sRGB data. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC2_UNORM_SRGB</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC3_Typeless">
            <summary>	
            Four-component typeless block-compression format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC3_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC3_UNorm">
            <summary>	
            Four-component block-compression format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC3_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC3_UNorm_SRgb">
            <summary>	
            Four-component block-compression format for sRGB data. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC3_UNORM_SRGB</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC4_Typeless">
            <summary>	
            One-component typeless block-compression format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC4_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC4_UNorm">
            <summary>	
            One-component block-compression format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC4_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC4_SNorm">
            <summary>	
            One-component block-compression format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC4_SNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC5_Typeless">
            <summary>	
            Two-component typeless block-compression format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC5_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC5_UNorm">
            <summary>	
            Two-component block-compression format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC5_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC5_SNorm">
            <summary>	
            Two-component block-compression format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC5_SNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.B5G6R5_UNorm">
            <summary>	
            A three-component, 16-bit unsigned-normalized integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_B5G6R5_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.B5G5R5A1_UNorm">
            <summary>	
            A four-component, 16-bit unsigned-normalized integer format that supports 1-bit alpha. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_B5G5R5A1_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.B8G8R8A8_UNorm">
            <summary>	
            A four-component, 32-bit unsigned-normalized integer format that supports 8-bit alpha. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_B8G8R8A8_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.B8G8R8X8_UNorm">
            <summary>	
            A four-component, 32-bit unsigned-normalized integer format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT_B8G8R8X8_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.R10G10B10_Xr_Bias_A2_UNorm">
            <summary>	
            A four-component, 32-bit format that supports 2-bit alpha. 4 	
            </summary>	
            <unmanaged>DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.B8G8R8A8_Typeless">
            <summary>	
            A four-component, 32-bit typeless format that supports 8-bit alpha. 4 	
            </summary>	
            <unmanaged>DXGI_FORMAT_B8G8R8A8_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.B8G8R8A8_UNorm_SRgb">
            <summary>	
            A four-component, 32-bit unsigned-normalized standard RGB format that supports 8-bit alpha. 4 	
            </summary>	
            <unmanaged>DXGI_FORMAT_B8G8R8A8_UNORM_SRGB</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.B8G8R8X8_Typeless">
            <summary>	
            A four-component, 32-bit typeless format. 4 	
            </summary>	
            <unmanaged>DXGI_FORMAT_B8G8R8X8_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.B8G8R8X8_UNorm_SRgb">
            <summary>	
            A four-component, 32-bit unsigned-normalized standard RGB format. 4 	
            </summary>	
            <unmanaged>DXGI_FORMAT_B8G8R8X8_UNORM_SRGB</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC6H_Typeless">
            <summary>	
            A typeless block-compression format. 4 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC6H_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC6H_Uf16">
            <summary>	
            A block-compression format. 4 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC6H_UF16</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC6H_Sf16">
            <summary>	
            A block-compression format. 4 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC6H_SF16</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC7_Typeless">
            <summary>	
            A typeless block-compression format. 4 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC7_TYPELESS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC7_UNorm">
            <summary>	
            A block-compression format. 4 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC7_UNORM</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Format.BC7_UNorm_SRgb">
            <summary>	
            A block-compression format. 4 	
            </summary>	
            <unmanaged>DXGI_FORMAT_BC7_UNORM_SRGB</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.DXGI">
            <summary>
            DXGI Functions.
            </summary>
        </member>
        <member name="M:SharpDX.DXGI.DXGI.#cctor">
            <summary>
            Load DLLs and bind functions
            </summary>
        </member>
        <member name="M:SharpDX.DXGI.DXGI.CreateDXGIFactory(System.Guid,System.IntPtr@)">
            <summary>	
            Creates a DXGI 1.0 factory that generates objects used to enumerate and specify video graphics settings.	
            </summary>	
            <remarks>	
            Use a DXGI factory to generate objects that {{enumerate adapters}}, {{create swap chains}}, and {{associate a window}} with the alt+enter key sequence for toggling to and from the fullscreen display mode. Note??Do not mix the use of DXGI 1.0 (<see cref="T:SharpDX.DXGI.Factory"/>) and DXGI 1.1 (<see cref="T:SharpDX.DXGI.Factory1"/>) in an application. Use IDXGIFactory or IDXGIFactory1, but not both in an application. 	
            </remarks>	
            <param name="riid">The globally unique identifier (GUID) of the <see cref="T:SharpDX.DXGI.Factory"/> object referenced by the ppFactory parameter. </param>
            <param name="factoryRef">Address of a reference to an <see cref="T:SharpDX.DXGI.Factory"/> object. </param>
            <returns>Returns S_OK if successful; otherwise, returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT CreateDXGIFactory([None] GUID* riid,[Out] void** ppFactory)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.DXGI.CreateDXGIFactory1(System.Guid,System.IntPtr@)">
            <summary>	
            Creates a DXGI 1.1 factory that generates objects used to enumerate and specify video graphics settings.	
            </summary>	
            <remarks>	
            Use a DXGI 1.1 factory to generate objects that {{enumerate adapters}},  {{create swap chains}}, and {{associate a window}} with  the alt+enter key sequence for toggling to and from the full-screen display mode.   This entry point is not supported by DXGI 1.0 shipped in Windows Vista and Windows Server 2008. DXGI 1.1 support is required which is available on  Windows 7, Windows Server 2008 R2, and as an update to Windows Vista (KB971644). Note??Do not mix the use of DXGI 1.0 (<see cref="T:SharpDX.DXGI.Factory"/>) and DXGI 1.1 (<see cref="T:SharpDX.DXGI.Factory1"/>) in an application. Use IDXGIFactory or IDXGIFactory1, but not both in an application. 	
            </remarks>	
            <param name="riid">The globally unique identifier (GUID) of the <see cref="T:SharpDX.DXGI.Factory1"/> object referenced by  the ppFactory parameter. </param>
            <param name="factoryRef">Address of a reference to an <see cref="T:SharpDX.DXGI.Factory1"/> object. </param>
            <returns>Returns S_OK if successful; an error code otherwise. For a list of error codes, see <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT CreateDXGIFactory1([None] GUID* riid,[Out] void** ppFactory)</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.Resource">
            <summary>	
            An IDXGIResource interface allows resource sharing and identifies the memory that a resource resides in.	
            </summary>	
            <unmanaged>IDXGIResource</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Resource.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.Resource"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.Resource.GetSharedHandle(System.IntPtr@)">
            <summary>	
            Get the handle to a shared resource. The returned handle can be used to open the resource using different Direct3D devices.	
            </summary>	
            <param name="sharedHandleRef">A reference to a handle. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIResource::GetSharedHandle([Out] void** pSharedHandle)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Resource.GetUsage(SharpDX.DXGI.Usage@)">
            <summary>	
            Get the expected resource usage.	
            </summary>	
            <param name="usageRef">A reference to a usage flag (see <see cref="T:SharpDX.DXGI.Usage"/>). For Direct3D 10, a surface can be used as a shader input or a render-target output. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIResource::GetUsage([Out] DXGI_USAGE* pUsage)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Resource.SetEvictionPriority(System.Int32)">
            <summary>	
            Set the priority for evicting the resource from memory.	
            </summary>	
            <remarks>	
            The eviction priority is a memory-management variable that is used by DXGI for determining how to populate overcommitted memory. You can set priority levels other than the defined values when appropriate. For example, you can set a resource with a priority level of 0x78000001 to indicate that the resource is slightly above normal. 	
            </remarks>	
            <param name="evictionPriority">The priority is one of the following values:   ValueMeaning  DXGI_RESOURCE_PRIORITY_MINIMUM (0x28000000)   The resource is unused and can be evicted as soon as another resource requires the memory that the resource occupies.   DXGI_RESOURCE_PRIORITY_LOW (0x50000000)   The eviction priority of the resource is low. The placement of the resource is not critical, and minimal work is performed to find a location for the resource. For example, if a GPU can render with a vertex buffer from either local or non-local memory with little difference in performance, that vertex buffer is low priority. Other more critical resources (for example, a render target or texture) can then occupy the faster memory.   DXGI_RESOURCE_PRIORITY_NORMAL (0x78000000)   The eviction priority of the resource is normal. The placement of the resource is important, but not critical, for performance. The resource is placed in its preferred location instead of a low-priority resource.    DXGI_RESOURCE_PRIORITY_HIGH (0xa0000000)   The eviction priority of the resource is high. The resource is placed in its preferred location instead of a low-priority or normal-priority resource.   DXGI_RESOURCE_PRIORITY_MAXIMUM (0xc8000000)   The resource is evicted from memory only if there is no other way of resolving the memory requirement.   ? </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIResource::SetEvictionPriority([None] int EvictionPriority)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Resource.GetEvictionPriority(System.Int32@)">
            <summary>	
            Get the eviction priority.	
            </summary>	
            <remarks>	
            The eviction priority is a memory-management variable that is used by DXGI to determine how to manage overcommitted memory. Priority levels other than the defined values are used when appropriate. For example, a resource with a priority level of 0x78000001 indicates that the resource is slightly above normal. 	
            </remarks>	
            <param name="evictionPriorityRef">A reference to the eviction priority, which determines when a resource can be evicted from memory.   The following defined values are possible.  ValueMeaning  DXGI_RESOURCE_PRIORITY_MINIMUM (0x28000000)   The resource is unused and can be evicted as soon as another resource requires the memory that the resource occupies.   DXGI_RESOURCE_PRIORITY_LOW (0x50000000)   The eviction priority of the resource is low. The placement of the resource is not critical, and minimal work is performed to find a location for the resource. For example, if a GPU can render with a vertex buffer from either local or non-local memory with little difference in performance, that vertex buffer is low priority. Other more critical resources (for example, a render target or texture) can then occupy the faster memory.   DXGI_RESOURCE_PRIORITY_NORMAL (0x78000000)   The eviction priority of the resource is normal. The placement of the resource is important, but not critical, for performance. The resource is placed in its preferred location instead of a low-priority resource.    DXGI_RESOURCE_PRIORITY_HIGH (0xa0000000)   The eviction priority of the resource is high. The resource is placed in its preferred location instead of a low-priority or normal-priority resource.   DXGI_RESOURCE_PRIORITY_MAXIMUM (0xc8000000)   The resource is evicted from memory only if there is no other way of resolving the memory requirement.   ? </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIResource::GetEvictionPriority([Out] int* pEvictionPriority)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.Resource.SharedHandle">
            <summary>	
            Get the handle to a shared resource. The returned handle can be used to open the resource using different Direct3D devices.	
            </summary>	
            <unmanaged>HRESULT IDXGIResource::GetSharedHandle([Out] void** pSharedHandle)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.Resource.Usage">
            <summary>	
            Get the expected resource usage.	
            </summary>	
            <unmanaged>HRESULT IDXGIResource::GetUsage([Out] DXGI_USAGE* pUsage)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.Resource.EvictionPriority">
            <summary>	
            Get the eviction priority.	
            </summary>	
            <remarks>	
            The eviction priority is a memory-management variable that is used by DXGI to determine how to manage overcommitted memory. Priority levels other than the defined values are used when appropriate. For example, a resource with a priority level of 0x78000001 indicates that the resource is slightly above normal. 	
            </remarks>	
            <unmanaged>HRESULT IDXGIResource::GetEvictionPriority([Out] int* pEvictionPriority)</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.KeyedMutex">
            <summary>	
            Represents a keyed mutex, which allows exclusive access to a shared resource that is used by multiple devices.	
            </summary>	
            <unmanaged>IDXGIKeyedMutex</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.KeyedMutex.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.KeyedMutex"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.KeyedMutex.Acquire(System.Int64,System.Int32)">
            <summary>	
            Using a key, acquires exclusive rendering access to a shared resource.	
            </summary>	
            <remarks>	
            The AcquireSync method creates a lock to a surface that is shared between multiple devices, allowing only one device to render to a surface at a time.   This method uses a key to determine which device currently has exclusive access to the surface. When a surface is created using the D3D10_RESOURCE_MISC_SHARED_KEYEDMUTEX value of the <see cref="!:SharpDX.Direct3D10.ResourceOptionFlags"/> enumeration,  you must call the AcquireSync method before rendering to the surface.  You must call the {{ReleaseSync}} method when you are done  rendering to a surface. To acquire a reference to the keyed mutex object of a shared resource, call the {{QueryInterface}} method of the resource and pass in  the UUID of the <see cref="T:SharpDX.DXGI.KeyedMutex"/> interface.  For more information about acquiring this reference, see the following code example. The AcquireSync method uses the key as follows, depending on the state of the surface:  On initial creation, the surface is unowned and any device can call the AcquireSync method to gain access.  For an unowned device, only a key of 0 will succeed. Calling the AcquireSync method for any other key will stall the  calling CPU thread. If the surface is owned by a device when you call the AcquireSync method, the CPU thread that called  the AcquireSync method will stall until the owning device calls the {{ReleaseSync}} method  using the same Key. If the surface is unowned when you call the AcquireSync method (for example, the last owning device has already called  the {{ReleaseSync}} method), the AcquireSync method will succeed if you specify the same key  that was specified when the ReleaseSync method was last called. Calling the AcquireSync method using  any other key will cause a stall. When the owning device calls the {{ReleaseSync}} method with a particular key, and more than one device is waiting after  calling the  AcquireSync method using the same key, any one of the waiting devices could be woken up first.  The order in which devices are woken up is undefined. A keyed mutex does not support recursive calls to the AcquireSync method.  	
            </remarks>	
            <param name="key">A value that indicates which device to give access to. This method will succeed when the device that currently owns the surface calls  the <see cref="M:SharpDX.DXGI.KeyedMutex.Release(System.Int64)"/> method using the same value. This value can be any UINT64 value. </param>
            <param name="dwMilliseconds">The time-out interval, in milliseconds. This method will return if the interval elapses, and the keyed mutex has not been released  using the specified Key.  If this value is set to zero, the AcquireSync method will test to see if the keyed mutex has been released and returns immediately.  If this value is set to INFINITE, the time-out interval will never elapse. </param>
            <returns>Return S_OK if successful. If the owning device attempted to create another keyed mutex on the same shared resource, AcquireSync returns E_FAIL. AcquireSync can also return the following {{DWORD}} constants. Therefore, you should explicitly check for these constants. If you only use the {{SUCCEEDED}} macro on the return value to determine if  AcquireSync succeeded, you will not catch these constants.  WAIT_ABANDONED - The shared surface and keyed mutex are no longer in a consistent state.  If AcquireSync returns this value, you should release and recreate both the keyed mutex and the shared surface. WAIT_TIMEOUT - The time-out interval elapsed before the specified key was released.  </returns>
            <unmanaged>HRESULT IDXGIKeyedMutex::AcquireSync([None] __int64 Key,[None] int dwMilliseconds)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.KeyedMutex.Release(System.Int64)">
            <summary>	
            Using a key, releases exclusive rendering access to a shared resource.	
            </summary>	
            <remarks>	
            The ReleaseSync method releases a lock to a surface that is shared between multiple devices.  This method uses a key to determine which device currently has exclusive access to the surface. When a surface is created using the D3D10_RESOURCE_MISC_SHARED_KEYEDMUTEX value of the <see cref="!:SharpDX.Direct3D10.ResourceOptionFlags"/> enumeration,  you must call the <see cref="M:SharpDX.DXGI.KeyedMutex.Acquire(System.Int64,System.Int32)"/> method before rendering to the surface.  You must call the ReleaseSync method when you are done  rendering to a surface. After you call the ReleaseSync method, the shared resource is unset from the rendering pipeline.  To acquire a reference to the keyed mutex object of a shared resource, call the {{QueryInterface}} method of the resource and pass in  the UUID of the <see cref="T:SharpDX.DXGI.KeyedMutex"/> interface.  For more information about acquiring this reference, see the following code example. 	
            </remarks>	
            <param name="key">A value that indicates which device to give access to. This method succeeds when the device that currently owns the surface calls the ReleaseSync method using the same value. This value can be any UINT64 value. </param>
            <returns>Returns S_OK if successful. If the device attempted to release a keyed mutex that is not valid or owned by the device, ReleaseSync returns E_FAIL. </returns>
            <unmanaged>HRESULT IDXGIKeyedMutex::ReleaseSync([None] __int64 Key)</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.Surface">
            <summary>	
            An IDXGISurface interface implements methods for image-data objects.	
            </summary>	
            <unmanaged>IDXGISurface</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Surface.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.Surface"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.Surface.GetDescription(SharpDX.DXGI.SurfaceDescription@)">
            <summary>	
            Get a description of the surface.	
            </summary>	
            <param name="descRef">A reference to the surface description (see <see cref="T:SharpDX.DXGI.SurfaceDescription"/>). </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGISurface::GetDesc([Out] DXGI_SURFACE_DESC* pDesc)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Surface.Map(SharpDX.DXGI.MappedRect@,System.Int32)">
            <summary>	
            Get a reference to the data contained in the surface, and deny GPU access to the surface.	
            </summary>	
            <remarks>	
            Use IDXGISurface::Map to access a surface from the CPU. To release a mapped surface (and allow GPU access) call <see cref="M:SharpDX.DXGI.Surface.Unmap"/>. 	
            </remarks>	
            <param name="lockedRectRef">A reference to the surface data (see <see cref="T:SharpDX.DXGI.MappedRect"/>). </param>
            <param name="mapFlags">CPU read-write flags. These flags can be combined with a logical OR.   DXGI_MAP_READ - Allow CPU read access. DXGI_MAP_WRITE - Allow CPU write access. DXGI_MAP_DISCARD - Discard the previous contents of a resource when it is mapped.  </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGISurface::Map([Out] DXGI_MAPPED_RECT* pLockedRect,[None] int MapFlags)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Surface.Unmap">
            <summary>	
            Invalidate the reference to the surface retrieved by <see cref="M:SharpDX.DXGI.Surface.Map(SharpDX.DXGI.MappedRect@,System.Int32)"/> and re-enable GPU access to the resource.	
            </summary>	
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGISurface::Unmap()</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Surface.Map(SharpDX.DXGI.MapFlags)">
            <summary>
            Acquires access to the surface data.
            </summary>
            <param name="flags">Flags specifying CPU access permissions.</param>
            <returns>A <see cref="T:SharpDX.DataRectangle" /> for accessing the mapped data, or <c>null</c> on failure.</returns>.
        </member>
        <member name="M:SharpDX.DXGI.Surface.FromSwapChain(SharpDX.DXGI.SwapChain,System.Int32)">
            <summary>
            Gets a swap chain back buffer.
            </summary>
            <param name="swapChain">The swap chain to get the buffer from.</param>
            <param name="index">The index of the desired buffer.</param>
            <returns>The buffer interface, or <c>null</c> on failure.</returns>
        </member>
        <member name="P:SharpDX.DXGI.Surface.Description">
            <summary>	
            Get a description of the surface.	
            </summary>	
            <unmanaged>HRESULT IDXGISurface::GetDesc([Out] DXGI_SURFACE_DESC* pDesc)</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.Surface1">
            <summary>	
            The IDXGISurface1 interface extends the <see cref="T:SharpDX.DXGI.Surface"/> by adding support for rendering to a DXGI interface using GDI.	
            </summary>	
            <unmanaged>IDXGISurface1</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Surface1.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.Surface1"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.Surface1.GetDC(System.Boolean)">
            <summary>	
            Returns a device context (DC) that allows you to render to a DXGI surface using GDI.	
            </summary>	
            <remarks>	
            After you use the GetDC method to retrieve a DC, you can render to the DXGI surface using GDI.   The GetDC method readies the surface for GDI rendering and allows interoperation between DXGI and GDI technologies.   Keep the following in mind when using this method:  You must create the surface using the D3D10_RESOURCE_MISC_GDI_COMPATIBLE flag for a surface or use the DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE flag for swap chains,  otherwise this method will fail. You must release the device and call the <see cref="M:SharpDX.DXGI.Surface1.ReleaseDC_(System.Nullable{SharpDX.Rectangle})"/> method before issuing any new Direct3D commands. This method will fail if an outstanding DC has already been created by this method. The format for the surface or swapchain must DXGI_FORMAT_B8G8R8A8_UNORM_SRGB or DXGI_FORMAT_B8G8R8A8_UNORM On GetDC, the render targer in the output merger of the Direct3D pipeline is unbound from the surface.   OMSetRenderTargets must be called on the device prior to Direct3D rendering after GDI rendering. Prior to resizing buffers you must release all outstanding DCs.  GetDC can also be called on the back buffer at index 0 of a swap chain by obtaining an <see cref="T:SharpDX.DXGI.Surface1"/> from the Swap Chain.   The following code illustrates the process. 	
            <code> IDXGISwapChain* g_pSwapChain = NULL;	
            IDXGISurface1* g_pSurface1 = NULL;	
            ...	
            //Setup the device and and swapchain	
            g_pSwapChain-&gt;GetBuffer(0, __uuidof(IDXGISurface1), (void**) &amp;g_pSurface1);	
            g_pSurface1-&gt;GetDC( FALSE, &amp;g_hDC );	
            ...      	
            //Draw on the DC using GDI	
            ...	
            //When finish drawing release the DC	
            g_pSurface1-&gt;ReleaseDC( NULL ); </code>	
            	
             	
            </remarks>	
            <param name="discard">If true the application will not preserve any rendering with GDI; otherwise, false.  If false, any previous rendering to the device context will be preserved.  This flag is ideal for simply reading the device context and not doing any rendering to the surface.  </param>
            <returns>A reference to an {{HDC}} handle that represents the current device context for GDI rendering. </returns>
            <unmanaged>HRESULT IDXGISurface1::GetDC([None] BOOL Discard,[Out] void** phdc)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Surface1.ReleaseDC_(System.Nullable{SharpDX.Rectangle})">
            <summary>	
            Releases the GDI device context (DC) associated with the current surface and allows rendering using Direct3D.	
            </summary>	
            <remarks>	
            Use the ReleaseDC method to release the DC and indicate that your application has finished all GDI rendering to this surface.   You must call the ReleaseDC method before you perform addition rendering using Direct3D. Prior to resizing buffers all outstanding DCs must be released. 	
            </remarks>	
            <param name="dirtyRectRef">A reference to a RECT structure that identifies the dirty region of the surface.   A dirty region is any part of the surface that you have used for GDI rendering and that you want to preserve.  This is used as a performance hint to graphics subsystem in certain scenarios.  Do not use this parameter to restrict rendering to the specified rectangular region.  Passing in NULL causes the whole surface to be considered dirty.  Otherwise the area specified by the RECT will be used as a performance hint to indicate what areas have been manipulated by GDI rendering. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDXGISurface1::ReleaseDC([In, Optional] RECT* pDirtyRect)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Surface1.ReleaseDC">
            <summary>	
            Releases the GDI device context (DC) associated with the current surface and allows rendering using Direct3D. The whole surface to be considered dirty.
            </summary>	
            <remarks>	
            Use the ReleaseDC method to release the DC and indicate that your application has finished all GDI rendering to this surface.   You must call the ReleaseDC method before you perform addition rendering using Direct3D. Prior to resizing buffers all outstanding DCs must be released. 	
            </remarks>	
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDXGISurface1::ReleaseDC([In, Optional] RECT* pDirtyRect)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Surface1.ReleaseDC(SharpDX.Rectangle)">
            <summary>	
            Releases the GDI device context (DC) associated with the current surface and allows rendering using Direct3D.	
            </summary>	
            <remarks>	
            Use the ReleaseDC method to release the DC and indicate that your application has finished all GDI rendering to this surface.   You must call the ReleaseDC method before you perform addition rendering using Direct3D. Prior to resizing buffers all outstanding DCs must be released. 	
            </remarks>	
            <param name="dirtyRect">A reference to a <see cref="T:SharpDX.Rectangle"/> structure that identifies the dirty region of the surface.   A dirty region is any part of the surface that you have used for GDI rendering and that you want to preserve.  This is used as a performance hint to graphics subsystem in certain scenarios.  Do not use this parameter to restrict rendering to the specified rectangular region. The area specified by the <see cref="T:SharpDX.Rectangle"/> will be used as a performance hint to indicate what areas have been manipulated by GDI rendering. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDXGISurface1::ReleaseDC([In, Optional] RECT* pDirtyRect)</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.Output">
            <summary>	
            An IDXGIOutput interface represents an adapter output (such as a monitor).	
            </summary>	
            <unmanaged>IDXGIOutput</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.Output"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.Output.GetDescription(SharpDX.DXGI.OutputDescription@)">
            <summary>	
            Get a description of the output.	
            </summary>	
            <param name="descRef">A reference to the output description (see <see cref="T:SharpDX.DXGI.OutputDescription"/>). </param>
            <returns>Returns a code that indicates success or failure. S_OK if successful, <see cref="F:SharpDX.DXGI.DXGIError.InvalidCall"/> if pDesc is passed in as NULL. </returns>
            <unmanaged>HRESULT IDXGIOutput::GetDesc([Out] DXGI_OUTPUT_DESC* pDesc)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.GetDisplayModeList(SharpDX.DXGI.Format,System.Int32,System.Int32@,SharpDX.DXGI.ModeDescription[])">
            <summary>	
            Gets the display modes that match the requested format and other input options.	
            </summary>	
            <remarks>	
            In general, when switching from windowed to full-screen mode, a swap chain automatically chooses a display mode that meets (or exceeds) the resolution, color  depth and refresh rate of the swap chain. To exercise more control over the display mode, use this API to poll the set of display modes that are validated  against monitor capabilities, or all modes that match the desktop (if the desktop settings are not validated against the monitor). As shown, this API is designed to be called twice. First to get the number of modes available, and second to return a description of the modes. 	
            <code> UINT num = 0;	
            DXGI_FORMAT format = DXGI_FORMAT_R32G32B32A32_FLOAT;	
            UINT flags         = DXGI_ENUM_MODES_INTERLACED; pOutput-&gt;GetDisplayModeList( format, flags, &amp;num, 0); ... DXGI_MODE_DESC * pDescs = new DXGI_MODE_DESC[num];	
            pOutput-&gt;GetDisplayModeList( format, flags, &amp;num, pDescs); </code>	
            	
             	
            </remarks>	
            <param name="enumFormat">The color format (see <see cref="T:SharpDX.DXGI.Format"/>). </param>
            <param name="flags">Options for modes to include (see {{DXGI_ENUM_MODES}}). DXGI_ENUM_MODES_SCALING needs to be specified to expose the display modes that require scaling.  Centered modes, requiring no  scaling and corresponding directly to the display output, are enumerated by default. </param>
            <param name="numModesRef">Set pDesc to NULL so that pNumModes returns the number of display modes that match the format and the options. Otherwise, pNumModes returns the number of display modes returned in pDesc. </param>
            <param name="descRef">A reference to a list of display modes (see <see cref="T:SharpDX.DXGI.ModeDescription"/>); set to NULL to get the number of display modes. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. It is rare, but possible, that the display modes available can change immediately after calling  this method, in which case DXGI_ERROR_MORE_DATA is returned (if there is not enough room for all the display modes).   If GetDisplayModeList is called from a Remote Desktop Services session (formerly Terminal Services session), DXGI_ERROR_NOT_CURRENTLY_AVAILABLE is returned. </returns>
            <unmanaged>HRESULT IDXGIOutput::GetDisplayModeList([None] DXGI_FORMAT EnumFormat,[None] int Flags,[InOut] int* pNumModes,[Out, Buffer, Optional] DXGI_MODE_DESC* pDesc)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.FindClosestMatchingMode(SharpDX.DXGI.ModeDescription@,SharpDX.DXGI.ModeDescription@,SharpDX.ComObject)">
            <summary>	
            Find the display mode that most closely matches the requested display mode.	
            </summary>	
            <remarks>	
            Direct3D devices require UNORM formats. This method finds the closest matching available display mode to the mode specified in pModeToMatch. Similarly ranked fields (ie. all specified, or all unspecified, etc) are resolved in the following order.  ScanlineOrdering Scaling Format Resolution RefreshRate  When determining the closest value for a particular field, previously matched fields are used to filter the display mode list choices, and  other fields are ignored. For example, when matching Resolution, the display mode list will have already been filtered by a certain ScanlineOrdering,  Scaling, and Format, while RefreshRate is ignored. This ordering doesn't define the absolute ordering for every usage scenario of FindClosestMatchingMode, because  the application can choose some values initially, effectively changing the order that fields are chosen. Fields of the display mode are matched one at a time, generally in a specified order. If a field is unspecified, FindClosestMatchingMode gravitates toward the values for the desktop related to this output.  If this output is not part of the desktop, then the default desktop output is used to find values. If an application uses a fully unspecified  display mode, FindClosestMatchingMode will typically return a display mode that matches the desktop settings for this output.   Unspecified fields are lower priority than specified fields and will be resolved later than specified fields. 	
            </remarks>	
            <param name="modeToMatchRef">The desired display mode (see <see cref="T:SharpDX.DXGI.ModeDescription"/>). Members of DXGI_MODE_DESC can be unspecified indicating no preference for  that member.  A value of 0 for Width or Height indicates the value is unspecified.  If either Width or  Height are 0 both must be 0.  A numerator and denominator of 0 in RefreshRate indicate it is unspecified. Other members  of DXGI_MODE_DESC have enumeration values indicating the member is unspecified.  If pConnectedDevice is NULL Format cannot be DXGI_FORMAT_UNKNOWN. </param>
            <param name="closestMatchRef">The mode that most closely matches pModeToMatch. </param>
            <param name="concernedDeviceRef">A reference to the Direct3D device interface. If this parameter is NULL, only modes whose format matches that of pModeToMatch will  be returned; otherwise, only those formats that are supported for scan-out by the device are returned. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIOutput::FindClosestMatchingMode([In] const DXGI_MODE_DESC* pModeToMatch,[Out] DXGI_MODE_DESC* pClosestMatch,[In, Optional] IUnknown* pConcernedDevice)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.WaitForVerticalBlank">
            <summary>	
            Halt a thread until the next vertical blank occurs.	
            </summary>	
            <remarks>	
            A vertical blank occurs when the raster moves from the lower right corner to the upper left corner to begin drawing the next frame. 	
            </remarks>	
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIOutput::WaitForVBlank()</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.TakeOwnership(SharpDX.ComObject,System.Boolean)">
            <summary>	
            Take ownership of an output.	
            </summary>	
            <remarks>	
            When you are finished with the output, call <see cref="M:SharpDX.DXGI.Output.ReleaseOwnership"/>. This method should not be called directly by applications, since results will be unpredictable. It is called implicitly by the DXGI swap chain object during fullscreen transitions, and should not be used as a substitute for swap chain methods. 	
            </remarks>	
            <param name="deviceRef">A reference to the IUnknown interface of a device (such as an <see cref="!:SharpDX.Direct3D10.Device"/>). </param>
            <param name="exclusive">Set to TRUE to enable other threads or applications to take ownership of the device; otherwise set to FALSE. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIOutput::TakeOwnership([In] IUnknown* pDevice,[None] BOOL Exclusive)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.ReleaseOwnership">
            <summary>	
            Release ownership of the output.	
            </summary>	
            <remarks>	
            If you are not using a swap chain, get access to an output by calling <see cref="M:SharpDX.DXGI.Output.TakeOwnership(SharpDX.ComObject,System.Boolean)"/> and release it when you are finished by calling IDXGIOutput::ReleaseOwnership. An application that uses a swap chain will typically not call either of these methods. 	
            </remarks>	
            <unmanaged>void IDXGIOutput::ReleaseOwnership()</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.GetGammaControlCapabilities(SharpDX.DXGI.GammaControlCapabilities@)">
            <summary>	
            Get a description of the gamma-control capabilities.	
            </summary>	
            <remarks>	
            Note??Calling this method is only supported while in full-screen mode. 	
            </remarks>	
            <param name="gammaCapsRef">A description of the gamma-control capabilities (see <see cref="T:SharpDX.DXGI.GammaControlCapabilities"/>). </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIOutput::GetGammaControlCapabilities([Out] DXGI_GAMMA_CONTROL_CAPABILITIES* pGammaCaps)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.SetGammaControl(SharpDX.DXGI.GammaControl@)">
            <summary>	
            Set the gamma controls.	
            </summary>	
            <remarks>	
            Note??Calling this method is only supported while in full-screen mode. 	
            </remarks>	
            <param name="arrayRef">A reference to an array of gamma controls (see <see cref="T:SharpDX.DXGI.GammaControl"/>). </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIOutput::SetGammaControl([In] const DXGI_GAMMA_CONTROL* pArray)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.GetGammaControl(SharpDX.DXGI.GammaControl@)">
            <summary>	
            Get the gamma control settings.	
            </summary>	
            <remarks>	
            Note??Calling this method is only supported while in full-screen mode. 	
            </remarks>	
            <param name="arrayRef">An array of gamma control settings (see <see cref="T:SharpDX.DXGI.GammaControl"/>). </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIOutput::GetGammaControl([Out] DXGI_GAMMA_CONTROL* pArray)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.SetDisplaySurface(SharpDX.DXGI.Surface)">
            <summary>	
            Change the display mode.	
            </summary>	
            <remarks>	
            IDXGIOutput::SetDisplaySurface should not be called directly by applications, since results will be unpredictable. It is called implicitly by the DXGI swap chain object during fullscreen transitions, and should not be used as a substitute for swap-chain methods. This method should only be called between <see cref="M:SharpDX.DXGI.Output.TakeOwnership(SharpDX.ComObject,System.Boolean)"/> and <see cref="M:SharpDX.DXGI.Output.ReleaseOwnership"/> calls. 	
            </remarks>	
            <param name="scanoutSurfaceRef">A reference to a surface (see <see cref="T:SharpDX.DXGI.Surface"/>) used for rendering an image to the screen. The surface must have been created with as a back buffer (DXGI_USAGE_BACKBUFFER). </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIOutput::SetDisplaySurface([In] IDXGISurface* pScanoutSurface)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.CopyDisplaySurfaceTo(SharpDX.DXGI.Surface)">
            <summary>	
            Get a copy of the current display surface.	
            </summary>	
            <remarks>	
            IDXGIOutput::GetDisplaySurfaceData can only be called when an output is in full-screen mode. If the method succeeds, the destination surface will be filled. Use <see cref="M:SharpDX.DXGI.Surface.GetDescription(SharpDX.DXGI.SurfaceDescription@)"/> to find out the size (width and height) when allocating space for the destination surface. This is true regardless of target monitor rotation. A destination surface created by a graphics component (such as Direct3D 10) must be created with CPU-write permission (see D3D10_CPU_ACCESS_WRITE). Other surfaces should be created with CPU read-write permission (see D3D10_CPU_ACCESS_READ_WRITE). This method will modify the surface data to fit the destination surface (stretch, shrink, convert format, rotate). The stretch and shrink is performed with point-sampling. 	
            </remarks>	
            <param name="destinationRef">A reference to a destination surface (see <see cref="T:SharpDX.DXGI.Surface"/>). </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIOutput::GetDisplaySurfaceData([In] IDXGISurface* pDestination)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.GetFrameStatistics(SharpDX.DXGI.FrameStatistics@)">
            <summary>	
            Get statistics about recently rendered frames.	
            </summary>	
            <remarks>	
            This API is similar to <see cref="M:SharpDX.DXGI.SwapChain.GetFrameStatistics(SharpDX.DXGI.FrameStatistics@)"/>.  Note??Calling this method is only supported while in full-screen mode. 	
            </remarks>	
            <param name="statsRef">A reference to a frame statictics (see <see cref="T:SharpDX.DXGI.FrameStatistics"/>). </param>
            <returns>If this function succeeds, it will return S_OK. Otherwise, it may return <see cref="F:SharpDX.DXGI.DXGIError.InvalidCall"/>. </returns>
            <unmanaged>HRESULT IDXGIOutput::GetFrameStatistics([Out] DXGI_FRAME_STATISTICS* pStats)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.GetClosestMatchingMode(SharpDX.ComObject,SharpDX.DXGI.ModeDescription,SharpDX.DXGI.ModeDescription@)">
            <summary>	
            Find the display mode that most closely matches the requested display mode.	
            </summary>	
            <remarks>	
            Direct3D devices require UNORM formats. This method finds the closest matching available display mode to the mode specified in pModeToMatch. Similarly ranked fields (ie. all specified, or all unspecified, etc) are resolved in the following order.  ScanlineOrdering Scaling Format Resolution RefreshRate  When determining the closest value for a particular field, previously matched fields are used to filter the display mode list choices, and  other fields are ignored. For example, when matching Resolution, the display mode list will have already been filtered by a certain ScanlineOrdering,  Scaling, and Format, while RefreshRate is ignored. This ordering doesn't define the absolute ordering for every usage scenario of FindClosestMatchingMode, because  the application can choose some values initially, effectively changing the order that fields are chosen. Fields of the display mode are matched one at a time, generally in a specified order. If a field is unspecified, FindClosestMatchingMode gravitates toward the values for the desktop related to this output.  If this output is not part of the desktop, then the default desktop output is used to find values. If an application uses a fully unspecified  display mode, FindClosestMatchingMode will typically return a display mode that matches the desktop settings for this output.   Unspecified fields are lower priority than specified fields and will be resolved later than specified fields. 	
            </remarks>	
            <param name="device">A reference to the Direct3D device interface. If this parameter is NULL, only modes whose format matches that of pModeToMatch will  be returned; otherwise, only those formats that are supported for scan-out by the device are returned. </param>
            <param name="modeToMatch">The desired display mode (see <see cref="T:SharpDX.DXGI.ModeDescription"/>). Members of DXGI_MODE_DESC can be unspecified indicating no preference for  that member.  A value of 0 for Width or Height indicates the value is unspecified.  If either Width or  Height are 0 both must be 0.  A numerator and denominator of 0 in RefreshRate indicate it is unspecified. Other members  of DXGI_MODE_DESC have enumeration values indicating the member is unspecified.  If pConnectedDevice is NULL Format cannot be DXGI_FORMAT_UNKNOWN. </param>
            <param name="closestMatch">The mode that most closely matches pModeToMatch. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGIOutput::FindClosestMatchingMode([In] const DXGI_MODE_DESC* pModeToMatch,[Out] DXGI_MODE_DESC* pClosestMatch,[In, Optional] IUnknown* pConcernedDevice)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Output.GetDisplayModeList(SharpDX.DXGI.Format,SharpDX.DXGI.DisplayModeEnumerationFlags)">
            <summary>	
            Gets the display modes that match the requested format and other input options.	
            </summary>	
            <remarks>	
            In general, when switching from windowed to full-screen mode, a swap chain automatically chooses a display mode that meets (or exceeds) the resolution, color  depth and refresh rate of the swap chain. To exercise more control over the display mode, use this API to poll the set of display modes that are validated  against monitor capabilities, or all modes that match the desktop (if the desktop settings are not validated against the monitor). As shown, this API is designed to be called twice. First to get the number of modes available, and second to return a description of the modes. 	
            <code> UINT num = 0;	
            DXGI_FORMAT format = DXGI_FORMAT_R32G32B32A32_FLOAT;	
            UINT flags         = DXGI_ENUM_MODES_INTERLACED; pOutput-&gt;GetDisplayModeList( format, flags, &amp;num, 0); ... DXGI_MODE_DESC * pDescs = new DXGI_MODE_DESC[num];	
            pOutput-&gt;GetDisplayModeList( format, flags, &amp;num, pDescs); </code>	
            	
             	
            </remarks>	
            <param name="format">The color format (see <see cref="T:SharpDX.DXGI.Format"/>). </param>
            <param name="flags">format for modes to include (see {{DXGI_ENUM_MODES}}). DXGI_ENUM_MODES_SCALING needs to be specified to expose the display modes that require scaling.  Centered modes, requiring no  scaling and corresponding directly to the display output, are enumerated by default. </param>
            <returns>Returns a list of display modes (see <see cref="T:SharpDX.DXGI.ModeDescription"/>); </returns>
            <unmanaged>HRESULT IDXGIOutput::GetDisplayModeList([None] DXGI_FORMAT EnumFormat,[None] int Flags,[InOut] int* pNumModes,[Out, Buffer, Optional] DXGI_MODE_DESC* pDesc)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.Output.Description">
            <summary>	
            Get a description of the output.	
            </summary>	
            <unmanaged>HRESULT IDXGIOutput::GetDesc([Out] DXGI_OUTPUT_DESC* pDesc)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.Output.GammaControlCapabilities">
            <summary>	
            Get a description of the gamma-control capabilities.	
            </summary>	
            <remarks>	
            Note??Calling this method is only supported while in full-screen mode. 	
            </remarks>	
            <unmanaged>HRESULT IDXGIOutput::GetGammaControlCapabilities([Out] DXGI_GAMMA_CONTROL_CAPABILITIES* pGammaCaps)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.Output.GammaControl">
            <summary>	
            Get the gamma control settings.	
            </summary>	
            <remarks>	
            Note??Calling this method is only supported while in full-screen mode. 	
            </remarks>	
            <unmanaged>HRESULT IDXGIOutput::GetGammaControl([Out] DXGI_GAMMA_CONTROL* pArray)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.Output.FrameStatistics">
            <summary>	
            Get statistics about recently rendered frames.	
            </summary>	
            <remarks>	
            This API is similar to <see cref="M:SharpDX.DXGI.SwapChain.GetFrameStatistics(SharpDX.DXGI.FrameStatistics@)"/>.  Note??Calling this method is only supported while in full-screen mode. 	
            </remarks>	
            <unmanaged>HRESULT IDXGIOutput::GetFrameStatistics([Out] DXGI_FRAME_STATISTICS* pStats)</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.SwapChain">
            <summary>	
            An IDXGISwapChain interface implements one or more {{surfaces}} for storing rendered data before presenting it to an output.	
            </summary>	
            <unmanaged>IDXGISwapChain</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.SwapChain"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.Present(System.Int32,SharpDX.DXGI.PresentFlags)">
            <summary>	
            Present a rendered image to the user.	
            </summary>	
            <remarks>	
            For the best performance when flipping swap-chain buffers in full-screen application, see {{Full-Screen Application Performance Hints}}. Because calling Present may cause the render thread to wait on the message-pump thread care should be taken when calling this method in an application that uses multiple threads. For more details, see {{Multithreading Considerations}}.   Differences between Direct3D 9 and Direct3D 10: Specifying DXGI_PRESENT_TEST in the Flags parameter is analogous to IDirect3DDevice9::TestCooperativeLevel in D3D9.   ? 	
            </remarks>	
            <param name="syncInterval">An integer that specifies the how to synchronize presentation of a frame with the vertical blank. Values are:  0 - The presentation occurs immediately, there is no synchronization. 1,2,3,4 - Synchronize presentation after the n'th vertical blank.  If the update region straddles more than one output (each represented by <see cref="T:SharpDX.DXGI.Output"/>), the synchronization will be performed to the output that contains the largest subrectangle of the target window's client area. </param>
            <param name="flags">An integer value that contains swap-chain presentation options (see {{DXGI_PRESENT}}). </param>
            <returns>Possible return values include: S_OK, DXGI_ERROR_DEVICE_RESET or DXGI_ERROR_DEVICE_REMOVED (see <see cref="T:SharpDX.DXGI.DXGIError"/>), DXGI_STATUS_OCCLUDED (see <see cref="T:SharpDX.DXGI.DXGIStatus"/>), or D3DDDIERR_DEVICEREMOVED.   Note that the Present method can return either DXGI_ERROR_DEVICE_REMOVED or D3DDDIERR_DEVICEREMOVED if a video card has been physically removed from the system, or a driver upgrade for the video card has occurred. </returns>
            <unmanaged>HRESULT IDXGISwapChain::Present([None] int SyncInterval,[None] DXGI_PRESENT_FLAGS Flags)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.GetBuffer(System.Int32,System.Guid,System.IntPtr@)">
            <summary>	
            Access one of the swap-chain back buffers.	
            </summary>	
            <remarks>	
            Here is an example. 	
            <code> ID3D10Texture2D * p_RT; ... // Get the surface from the swap chain pSwapChain-&gt;GetBuffer(0, __uuidof(p_RT), reinterpret_cast&lt;void**&gt;(&amp;p_RT)); </code>	
            	
             	
            </remarks>	
            <param name="buffer">A zero-based buffer index. If the swap effect is not DXGI_SWAP_EFFECT_SEQUENTIAL, this method only has access to the first buffer; for this case, set the index to zero. </param>
            <param name="riid">The type of interface used to manipulate the buffer. See remarks. </param>
            <param name="surfaceRef">A reference to a back-buffer interface. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGISwapChain::GetBuffer([None] int Buffer,[In] GUID* riid,[Out] void** ppSurface)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.SetFullscreenState(System.Boolean,SharpDX.DXGI.Output)">
            <summary>	
            Sets the display state to windowed or full-screen.	
            </summary>	
            <remarks>	
            DXGI may change the display state of a swap chain is response to user or system requests. 	
            </remarks>	
            <param name="fullscreen">Use TRUE for full-screen, FALSE for windowed. </param>
            <param name="targetRef">If you pass TRUE to the Fullscreen parameter to set the display state to full-screen, you can optionally set this parameter to the output target (see <see cref="T:SharpDX.DXGI.Output"/>) that contains the swap chain. If you set this parameter to NULL, DXGI will choose the output based on the swap-chain's device and the output window's  placement. If you pass FALSE to Fullscreen, you must set this parameter to NULL. </param>
            <returns>This methods returns:   S_OK if the action succeeded and the swap chain was placed in the requested state. DXGI_ERROR_NOT_CURRENTLY_AVAILABLE if the action failed. There are many reasons why a windowed-mode swap chain cannot switch to full-screen mode. For instance:  The application is running over Terminal Server. The output window is occluded. The output window does not have keyboard focus. Another application is already in full-screen mode.  When this error is returned, an application can continue to run in windowed mode and try to switch to full-screen mode later.  DXGI_STATUS_MODE_CHANGE_IN_PROGRESS is returned if a fullscreen/windowed mode transition is occurring when this API is called. Other error codes if you run out of memory or encounter another unexpected fault; these codes may be treated as hard, non-continuable errors.  </returns>
            <unmanaged>HRESULT IDXGISwapChain::SetFullscreenState([None] BOOL Fullscreen,[In, Optional] IDXGIOutput* pTarget)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.GetFullscreenState(System.Int32@,SharpDX.DXGI.Output@)">
            <summary>	
            Get the state associated with full-screen mode.	
            </summary>	
            <remarks>	
            When the swap chain is in full-screen mode, a reference to the  target output will be returned and its reference count will be incremented. 	
            </remarks>	
            <param name="fullscreenRef">A reference to a boolean whose value is either:  TRUE if the swap chain is in full-screen mode FALSE if the swap chain is in windowed mode  </param>
            <param name="targetRef">A reference to the output target (see <see cref="T:SharpDX.DXGI.Output"/>) when the mode is full screen; otherwise NULL. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGISwapChain::GetFullscreenState([Out] BOOL* pFullscreen,[Out] IDXGIOutput** ppTarget)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.GetDescription(SharpDX.DXGI.SwapChainDescription@)">
            <summary>	
            Get a description of the swap chain.	
            </summary>	
            <param name="descRef">A reference to the swap-chain description (see <see cref="T:SharpDX.DXGI.SwapChainDescription"/>). </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGISwapChain::GetDesc([Out] DXGI_SWAP_CHAIN_DESC* pDesc)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.ResizeBuffers(System.Int32,System.Int32,System.Int32,SharpDX.DXGI.Format,System.Int32)">
            <summary>	
            Change the swap chain's back buffer size, format, and number of buffers. This should be called when the application window is resized.	
            </summary>	
            <remarks>	
            A swapchain cannot be resized unless all outstanding references to its back buffers have been released. The application must release all of its direct and indirect references on the backbuffers in order for ResizeBuffers to succeed. Direct references are held by the application after calling AddRef on a resource. Indirect references are held by views to a resource, binding a view of the resource to a device context,  a command list that used the resource, a command list that used a view to that resource, a command list that executed another command list that used the  resource, etc. Before calling ResizeBuffers, ensure that the application releases all references (by calling the appropriate number of Release invocations)  on the resources, any views to the resource, any command lists that use either the resources or views, and ensure that neither the resource, nor a view is  still bound to a device context.  ClearState can be used to ensure this. If a view is bound to a deferred context, then the partially built command list must be discarded  as well (by calling ClearState, FinishCommandList, then Release on the command list).   The application can re-query interfaces after calling ResizeBuffers via <see cref="M:SharpDX.DXGI.SwapChain.GetBuffer(System.Int32,System.Guid,System.IntPtr@)"/>. This method should be called whenever a client window is resized. It is recommended to call this API when an application receives a WM_SIZE message. 	
            </remarks>	
            <param name="bufferCount">The number of buffers in the swap chain (including all back and front buffers). This can be different from the number of buffers the swap chain  was created with. </param>
            <param name="width">New width of the back buffer. If 0 is specified the width of the client area of the target window will be used. </param>
            <param name="height">New height of the back buffer. If 0 is specified the height of the client area of the target window will be used. </param>
            <param name="newFormat">The new format of the back buffer. See <see cref="T:SharpDX.DXGI.Format"/>. </param>
            <param name="swapChainFlags">Flags that indicate how the swap chain will function. See <see cref="T:SharpDX.DXGI.SwapChainFlags"/>. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGISwapChain::ResizeBuffers([None] int BufferCount,[None] int Width,[None] int Height,[None] DXGI_FORMAT NewFormat,[None] int SwapChainFlags)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.ResizeTarget(SharpDX.DXGI.ModeDescription@)">
            <summary>	
            Resize the output target.	
            </summary>	
            <remarks>	
            This function resizes the target window when the swap chain is in windowed mode, and changes the display mode on the target output when the swap  chain is in full-screen mode. Therefore, applications can call this method to resize the target window (rather than a win32 API such as SetWindowPos)  without knowledge of the swap chain display mode. 	
            </remarks>	
            <param name="newTargetParametersRef">A reference to the mode description (see <see cref="T:SharpDX.DXGI.ModeDescription"/>), which specifies the new width, height, format and refresh rate of the target.  If the format is DXGI_FORMAT_UNKNOWN, the existing format will be used. Using DXGI_FORMAT_UNKNOWN is only recommended when the swap chain is in full-screen  mode as this method is not thread safe. </param>
            <returns>Returns a code that indicates success or failure. DXGI_STATUS_MODE_CHANGE_IN_PROGRESS is returned if a fullscreen/windowed mode transition is occurring  when this API is called. See <see cref="T:SharpDX.DXGI.DXGIError"/> for additional DXGI error codes. </returns>
            <unmanaged>HRESULT IDXGISwapChain::ResizeTarget([In] const DXGI_MODE_DESC* pNewTargetParameters)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.GetContainingOutput(SharpDX.DXGI.Output@)">
            <summary>	
            Get the output (the display monitor) that contains the majority of the client area of the target window.	
            </summary>	
            <remarks>	
            If the method succeeds, the output interface will be filled and its reference count incremented. When you are finished with it, be sure to release the interface to avoid a memory leak. The output is also owned by the adapter on which the swap chain's device was created. 	
            </remarks>	
            <param name="outputRef">A reference to the output interface (see <see cref="T:SharpDX.DXGI.Output"/>). </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGISwapChain::GetContainingOutput([Out] IDXGIOutput** ppOutput)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.GetFrameStatistics(SharpDX.DXGI.FrameStatistics@)">
            <summary>	
            Get performance statistics about the last render frame.	
            </summary>	
            <remarks>	
            This method is not supported when the swap chain is windowed. 	
            </remarks>	
            <param name="statsRef">A reference to the frame statistics (see <see cref="T:SharpDX.DXGI.FrameStatistics"/>). </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGISwapChain::GetFrameStatistics([Out] DXGI_FRAME_STATISTICS* pStats)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.GetLastPresentCount(System.Int32@)">
            <summary>	
            Get the number of times <see cref="M:SharpDX.DXGI.SwapChain.Present(System.Int32,SharpDX.DXGI.PresentFlags)"/> has been called.	
            </summary>	
            <param name="lastPresentCountRef">A reference to the number of calls. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGISwapChain::GetLastPresentCount([Out] int* pLastPresentCount)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.#ctor(SharpDX.DXGI.Factory,SharpDX.ComObject,SharpDX.DXGI.SwapChainDescription)">
            <summary>	
            Creates a swap chain.	
            </summary>	
            <remarks>	
            If you attempt to create a swap chain in full-screen mode, and full-screen mode is unavailable, the swap chain will be created in windowed mode and DXGI_STATUS_OCCLUDED will be returned. If the buffer width or the buffer height are zero, the sizes will be inferred from the output window size in the swap-chain description. Since the target output cannot be chosen explicitly when the swap-chain is created, you should not create a full-screen swap chain. This can reduce presentation performance if the swap chain size and the output window size do not match. Here are two ways to ensure the sizes match:  Create a windowed swap chain and then set it full-screen using <see cref="M:SharpDX.DXGI.SwapChain.SetFullscreenState(System.Boolean,SharpDX.DXGI.Output)"/>. Save a reference to the swap-chain immediately after creation, and use it to get the output window size during a WM_SIZE event. Then resize the swap chain buffers (with <see cref="M:SharpDX.DXGI.SwapChain.ResizeBuffers(System.Int32,System.Int32,System.Int32,SharpDX.DXGI.Format,System.Int32)"/>) during the transition from windowed to full-screen.  If the swap chain is in full-screen mode, before you release it, you must use {{SetFullscreenState}} to switch it to windowed mode. For more information about releasing a swap chain, see the Destroying a Swap Chain section of {{DXGI Overview}}. 	
            </remarks>	
            <param name="factory">a reference to a <see cref="T:SharpDX.DXGI.Factory"/>.</param>
            <param name="device">A reference to the device that will write 2D images to the swap chain. </param>
            <param name="description">A reference to the swap-chain description (see <see cref="T:SharpDX.DXGI.SwapChainDescription"/>).</param>
            <unmanaged>HRESULT IDXGIFactory::CreateSwapChain([In] IUnknown* pDevice,[In] DXGI_SWAP_CHAIN_DESC* pDesc,[Out] IDXGISwapChain** ppSwapChain)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.GetBackBuffer``1(System.Int32)">
            <summary>
            Access one of the swap-chain back buffers.
            </summary>
            <typeparam name="T">The interface of the surface to resolve from the back buffer</typeparam>
            <param name="index">A zero-based buffer index. If the swap effect is not DXGI_SWAP_EFFECT_SEQUENTIAL, this method only has access to the first buffer; for this case, set the index to zero.</param>
            <returns>
            Returns a reference to a back-buffer interface.
            </returns>
            <unmanaged>HRESULT IDXGISwapChain::GetBuffer([None] int Buffer,[In] GUID* riid,[Out] void** ppSurface)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SwapChain.GetFullScreenState(System.Boolean@,SharpDX.DXGI.Output@)">
            <summary>	
            Get the state associated with full-screen mode.	
            </summary>	
            <remarks>	
            When the swap chain is in full-screen mode, a reference to the  target output will be returned and its reference count will be incremented. 	
            </remarks>	
            <param name="isFullScreen">A reference to a boolean whose value is either:  TRUE if the swap chain is in full-screen mode FALSE if the swap chain is in windowed mode  </param>
            <param name="target">A reference to the output target (see <see cref="T:SharpDX.DXGI.Output"/>) when the mode is full screen; otherwise NULL. </param>
            <returns>Returns one of the following <see cref="T:SharpDX.DXGI.DXGIError"/>. </returns>
            <unmanaged>HRESULT IDXGISwapChain::GetFullscreenState([Out] BOOL* pFullscreen,[Out] IDXGIOutput** ppTarget)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.SwapChain.Description">
            <summary>	
            Get a description of the swap chain.	
            </summary>	
            <unmanaged>HRESULT IDXGISwapChain::GetDesc([Out] DXGI_SWAP_CHAIN_DESC* pDesc)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.SwapChain.ContainingOutput">
            <summary>	
            Get the output (the display monitor) that contains the majority of the client area of the target window.	
            </summary>	
            <remarks>	
            If the method succeeds, the output interface will be filled and its reference count incremented. When you are finished with it, be sure to release the interface to avoid a memory leak. The output is also owned by the adapter on which the swap chain's device was created. 	
            </remarks>	
            <unmanaged>HRESULT IDXGISwapChain::GetContainingOutput([Out] IDXGIOutput** ppOutput)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.SwapChain.FrameStatistics">
            <summary>	
            Get performance statistics about the last render frame.	
            </summary>	
            <remarks>	
            This method is not supported when the swap chain is windowed. 	
            </remarks>	
            <unmanaged>HRESULT IDXGISwapChain::GetFrameStatistics([Out] DXGI_FRAME_STATISTICS* pStats)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.SwapChain.LastPresentCount">
            <summary>	
            Get the number of times <see cref="M:SharpDX.DXGI.SwapChain.Present(System.Int32,SharpDX.DXGI.PresentFlags)"/> has been called.	
            </summary>	
            <unmanaged>HRESULT IDXGISwapChain::GetLastPresentCount([Out] int* pLastPresentCount)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.SwapChain.IsFullScreen">
            <summary>
            Gets or sets a value indicating whether the swapchain is in fullscreen.
            </summary>
            <value>
            	<c>true</c> if this swapchain is in fullscreen; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:SharpDX.DXGI.Adapter1">
            <summary>	
            The IDXGIAdapter1 interface represents a display sub-system (including one or more GPU's, DACs and video memory).	
            </summary>	
            <unmanaged>IDXGIAdapter1</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Adapter1.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.Adapter1"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.Adapter1.GetDescription1(SharpDX.DXGI.AdapterDescription1@)">
            <summary>	
            Gets a DXGI 1.1 description of an adapter (or video card).	
            </summary>	
            <remarks>	
            Use the GetDesc1 method to get a DXGI 1.1 description of an adapter.  To get a DXGI 1.0 description, use the <see cref="T:SharpDX.DXGI.Adapter"/> method. 	
            </remarks>	
            <param name="descRef">A reference to a <see cref="T:SharpDX.DXGI.AdapterDescription1"/> structure that describes the adapter.   This parameter must not be NULL. </param>
            <returns>Returns S_OK if successful; otherwise returns an error code.  Returns <see cref="F:SharpDX.DXGI.DXGIError.InvalidCall"/> if the pDesc parameter is NULL.   For a list of error codes, see DXGI_ERROR. </returns>
            <unmanaged>HRESULT IDXGIAdapter1::GetDesc1([Out] DXGI_ADAPTER_DESC1* pDesc)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.Adapter1.Description1">
            <summary>	
            Gets a DXGI 1.1 description of an adapter (or video card).	
            </summary>	
            <remarks>	
            Use the GetDesc1 method to get a DXGI 1.1 description of an adapter.  To get a DXGI 1.0 description, use the <see cref="T:SharpDX.DXGI.Adapter"/> method. 	
            </remarks>	
            <unmanaged>HRESULT IDXGIAdapter1::GetDesc1([Out] DXGI_ADAPTER_DESC1* pDesc)</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.Device1">
            <summary>	
            An IDXGIDevice1 interface implements a derived class for DXGI objects that produce image data.	
            </summary>	
            <unmanaged>IDXGIDevice1</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Device1.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DXGI.Device1"/> class.
            </summary>
            <param name="nativePtr">The native pointer.</param>	
        </member>
        <member name="M:SharpDX.DXGI.Device1.SetMaximumFrameLatency(System.Int32)">
            <summary>	
            Sets the number of frames that the system is allowed to queue for rendering.	
            </summary>	
            <remarks>	
            Frame latency is the number of frames that are allowed to be stored in a queue before submission for rendering.  Latency is often used to  control how the CPU chooses between responding to user input and frames that are in the render queue.  It is often beneficial for applications that  have no user input (for example, video playback) to queue more than 3 frames of data. 	
            </remarks>	
            <param name="maxLatency">The maximum number of back buffer frames that a driver can queue. The value defaults to 3, but  can range from 1 to 16. A value of 0 will reset latency to the default.  For multi-head devices, this value is specified per-head. </param>
            <returns>Returns S_OK if successful; otherwise, DXGI_ERROR_DEVICE_REMOVED if the device was removed. </returns>
            <unmanaged>HRESULT IDXGIDevice1::SetMaximumFrameLatency([None] int MaxLatency)</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Device1.GetMaximumFrameLatency(System.Int32@)">
            <summary>	
            Gets the number of frames that the system is allowed to queue for rendering.	
            </summary>	
            <remarks>	
            Frame latency is the number of frames that are allowed to be stored in a queue before submission for rendering.  Latency is often  used to control how the CPU chooses between responding to user input and frames that are in the render queue.  It is often beneficial for applications  that have no user input (for example, video playback) to queue more than 3 frames of data. 	
            </remarks>	
            <param name="maxLatencyRef">This value is set to the number of frames that can be queued for render.   This value defaults to 3, but can range from 1 to 16. </param>
            <returns>Returns S_OK if successful; otherwise, returns one of the following members of the {{D3DERR}} enumerated type:   D3DERR_DEVICELOST   D3DERR_DEVICEREMOVED   D3DERR_DRIVERINTERNALERROR   D3DERR_INVALIDCALL   D3DERR_OUTOFVIDEOMEMORY   </returns>
            <unmanaged>HRESULT IDXGIDevice1::GetMaximumFrameLatency([Out] int* pMaxLatency)</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.Device1.MaximumFrameLatency">
            <summary>	
            Gets the number of frames that the system is allowed to queue for rendering.	
            </summary>	
            <remarks>	
            Frame latency is the number of frames that are allowed to be stored in a queue before submission for rendering.  Latency is often  used to control how the CPU chooses between responding to user input and frames that are in the render queue.  It is often beneficial for applications  that have no user input (for example, video playback) to queue more than 3 frames of data. 	
            </remarks>	
            <unmanaged>HRESULT IDXGIDevice1::GetMaximumFrameLatency([Out] int* pMaxLatency)</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.FrameStatistics">
            <summary>	
            Describes timing and presentation statistics for a frame.	
            </summary>	
            <remarks>	
            The DXGI_FRAME_STATISTICS structure is initialized by the <see cref="M:SharpDX.DXGI.Output.GetFrameStatistics(SharpDX.DXGI.FrameStatistics@)"/> method or by  the <see cref="M:SharpDX.DXGI.SwapChain.GetFrameStatistics(SharpDX.DXGI.FrameStatistics@)"/> method. 	
            </remarks>	
            <unmanaged>DXGI_FRAME_STATISTICS</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.FrameStatistics.PresentCount">
            <summary>	
            A value representing the running total count of times that an image has been presented to the monitor since the computer booted.  Note that the number of times that an image has been presented to the monitor is not necessarily the same as the number of times  that <see cref="M:SharpDX.DXGI.SwapChain.Present(System.Int32,SharpDX.DXGI.PresentFlags)"/> has been called. 	
            </summary>	
            <unmanaged>int PresentCount</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.FrameStatistics.PresentRefreshCount">
            <summary>	
            A value representing  the running total count of v-blanks that have happened since the computer booted. 	
            </summary>	
            <unmanaged>int PresentRefreshCount</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.FrameStatistics.SyncRefreshCount">
            <summary>	
            A value representing  the running total count of v-blanks that have happened since the computer booted. 	
            </summary>	
            <unmanaged>int SyncRefreshCount</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.FrameStatistics.SyncQPCTime">
            <summary>	
            A value representing the high-resolution performance counter timer.  This value is the same as the value returned by the {{QueryPerformanceCounter}} function. 	
            </summary>	
            <unmanaged>__int64 SyncQPCTime</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.FrameStatistics.SyncGPUTime">
            <summary>	
            Reserved. Always returns 0. 	
            </summary>	
            <unmanaged>__int64 SyncGPUTime</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.MappedRect">
            <summary>	
            A mapped rectangle used for accessing a surface.	
            </summary>	
            <remarks>	
            The DXGI_MAPPED_RECT structure is initialized by the <see cref="M:SharpDX.DXGI.Surface.Map(SharpDX.DXGI.MappedRect@,System.Int32)"/> method. 	
            </remarks>	
            <unmanaged>DXGI_MAPPED_RECT</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.MappedRect.Pitch">
            <summary>	
            A value describing the width of the surface. 	
            </summary>	
            <unmanaged>int Pitch</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.MappedRect.PBits">
            <summary>	
            A reference to the image buffer of the surface. 	
            </summary>	
            <unmanaged>byte* pBits</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.AdapterDescription">
            <summary>	
            Describes an adapter (or video card) by using DXGI 1.0.	
            </summary>	
            <remarks>	
            The DXGI_ADAPTER_DESC structure provides a description of an adapter.  This structure is initialized by using the <see cref="M:SharpDX.DXGI.Adapter.GetDescription(SharpDX.DXGI.AdapterDescription@)"/> method. 	
            </remarks>	
            <unmanaged>DXGI_ADAPTER_DESC</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription.Description">
            <summary>	
            A string that contains the adapter description. 	
            </summary>	
            <unmanaged>wchar_t Description[128]</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription.VendorId">
            <summary>	
            The PCI ID of the hardware vendor. 	
            </summary>	
            <unmanaged>int VendorId</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription.DeviceId">
            <summary>	
            The PCI ID of the hardware device. 	
            </summary>	
            <unmanaged>int DeviceId</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription.SubsystemId">
            <summary>	
            The PCI ID of the sub system. 	
            </summary>	
            <unmanaged>int SubSysId</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription.Revision">
            <summary>	
            The PCI ID of the revision number of the adapter. 	
            </summary>	
            <unmanaged>int Revision</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription.DedicatedVideoMemory">
            <summary>	
            The number of bytes of dedicated video memory that are not shared with the CPU. 	
            </summary>	
            <unmanaged>SIZE_T DedicatedVideoMemory</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription.DedicatedSystemMemory">
            <summary>	
            The number of bytes of dedicated system memory that are not shared with the GPU. This memory is allocated from available system memory at boot time. 	
            </summary>	
            <unmanaged>SIZE_T DedicatedSystemMemory</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription.SharedSystemMemory">
            <summary>	
            The number of bytes of shared system memory. This is the maximum value of system memory that may be consumed by the adapter during operation. Any incidental memory consumed by the driver as it manages and uses video memory is additional. 	
            </summary>	
            <unmanaged>SIZE_T SharedSystemMemory</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription.Luid">
            <summary>	
            A unique value that identifies the adapter. See {{LUID}} for a definition of the structure. LUID is defined in dxgi.h. 	
            </summary>	
            <unmanaged>__int64 AdapterLuid</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.OutputDescription">
            <summary>	
            Describes an output or physical connection between the adapter (video card) and a device.	
            </summary>	
            <remarks>	
            The DXGI_OUTPUT_DESC structure is initialized by the <see cref="M:SharpDX.DXGI.Output.GetDescription(SharpDX.DXGI.OutputDescription@)"/> method. 	
            </remarks>	
            <unmanaged>DXGI_OUTPUT_DESC</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.OutputDescription.DeviceName">
            <summary>	
            A string that contains the name of the output device. 	
            </summary>	
            <unmanaged>wchar_t DeviceName[32]</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.OutputDescription.DesktopBounds">
            <summary>	
            A <see cref="T:SharpDX.Rectangle"/> structure containing the bounds of the output in desktop coordinates. 	
            </summary>	
            <unmanaged>RECT DesktopCoordinates</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.OutputDescription.Rotation">
            <summary>	
            A member of the <see cref="T:SharpDX.DXGI.DisplayModeRotation"/> enumerated type describing on how an image is rotated by the output. 	
            </summary>	
            <unmanaged>DXGI_MODE_ROTATION Rotation</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.OutputDescription.MonitorHandle">
            <summary>	
            An {{HMONITOR}} handle that represents the display monitor. For more information, see {{HMONITOR and the Device Context}}. 	
            </summary>	
            <unmanaged>void* Monitor</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.OutputDescription.IsAttachedToDesktop">
            <summary>	
            True if the output is attached to the desktop; otherwise, false. 	
            </summary>	
            <unmanaged>BOOL AttachedToDesktop</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.SharedResource">
            <summary>	
            Represents a handle to a shared resource.	
            </summary>	
            <remarks>	
            To create a shared surface, pass a shared-resource handle into the <see cref="M:SharpDX.DXGI.Device.CreateSurface(SharpDX.DXGI.SurfaceDescription@,System.Int32,SharpDX.DXGI.Usage,System.Nullable{SharpDX.DXGI.SharedResource},SharpDX.DXGI.Surface@)"/> method. 	
            </remarks>	
            <unmanaged>DXGI_SHARED_RESOURCE</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SharedResource.Handle">
            <summary>	
            A handle to a shared resource. 	
            </summary>	
            <unmanaged>void* Handle</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.SurfaceDescription">
            <summary>	
            Describes a surface.	
            </summary>	
            <unmanaged>DXGI_SURFACE_DESC</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SurfaceDescription.Width">
            <summary>	
            A value describing the surface width. 	
            </summary>	
            <unmanaged>int Width</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SurfaceDescription.Height">
            <summary>	
            A value describing the surface height. 	
            </summary>	
            <unmanaged>int Height</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SurfaceDescription.Format">
            <summary>	
            A member of the <see cref="T:SharpDX.DXGI.Format"/> enumerated type that describes the surface format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT Format</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SurfaceDescription.SampleDescription">
            <summary>	
            A member of the <see cref="T:SharpDX.DXGI.SampleDescription"/> structure that describes multi-sampling parameters for the surface. 	
            </summary>	
            <unmanaged>DXGI_SAMPLE_DESC SampleDesc</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.SwapChainDescription">
            <summary>	
            Describes a swap chain.	
            </summary>	
            <remarks>	
            In full-screen mode, there is a dedicated front buffer; in windowed mode, the desktop is the front buffer. If you create a swap chain with one buffer, specifying DXGI_SWAP_EFFECT_SEQUENTIAL does not cause the contents of the single  buffer to be swapped with the front buffer. For performance information about flipping swap-chain buffers in full-screen application,  see {{Full-Screen Application Performance Hints}}. 	
            </remarks>	
            <unmanaged>DXGI_SWAP_CHAIN_DESC</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SwapChainDescription.ModeDescription">
            <summary>	
            A <see cref="T:SharpDX.DXGI.ModeDescription"/> structure that describes the backbuffer display mode. 	
            </summary>	
            <unmanaged>DXGI_MODE_DESC BufferDesc</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SwapChainDescription.SampleDescription">
            <summary>	
            A <see cref="T:SharpDX.DXGI.SampleDescription"/> structure that describes multi-sampling parameters. 	
            </summary>	
            <unmanaged>DXGI_SAMPLE_DESC SampleDesc</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SwapChainDescription.Usage">
            <summary>	
            A member of the <see cref="T:SharpDX.DXGI.Usage"/> enumerated type that describes the surface usage and CPU access options for the back buffer. The back buffer can  be used for shader input or render-target output. 	
            </summary>	
            <unmanaged>DXGI_USAGE BufferUsage</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SwapChainDescription.BufferCount">
            <summary>	
            A value that describes the number of buffers in the swap chain. When you call  <see cref="M:SharpDX.DXGI.Factory.CreateSwapChain(SharpDX.ComObject,SharpDX.DXGI.SwapChainDescription@,SharpDX.DXGI.SwapChain@)"/> to create a full-screen swap chain, you typically include the front buffer in this value. For more information about swap-chain buffers, see Remarks. 	
            </summary>	
            <unmanaged>int BufferCount</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SwapChainDescription.OutputHandle">
            <summary>	
            An {{HWND}} handle to the output window. This member must not be NULL. 	
            </summary>	
            <unmanaged>void* OutputWindow</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SwapChainDescription.SwapEffect">
            <summary>	
            A member of the <see cref="T:SharpDX.DXGI.SwapEffect"/> enumerated type that describes options for handling the contents of the presentation buffer after  presenting a surface. 	
            </summary>	
            <unmanaged>DXGI_SWAP_EFFECT SwapEffect</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SwapChainDescription.Flags">
            <summary>	
            A member of the <see cref="T:SharpDX.DXGI.SwapChainFlags"/> enumerated type that describes options for swap-chain behavior. 	
            </summary>	
            <unmanaged>DXGI_SWAP_CHAIN_FLAG Flags</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.SwapChainDescription.IsWindowed">
            <summary>	
            True if the output is in windowed mode; otherwise, false. For more information, see <see cref="M:SharpDX.DXGI.Factory.CreateSwapChain(SharpDX.ComObject,SharpDX.DXGI.SwapChainDescription@,SharpDX.DXGI.SwapChain@)"/>. 	
            </summary>	
            <unmanaged>BOOL Windowed</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.AdapterDescription1">
            <summary>	
            Describes an adapter (or video card) using DXGI 1.1.	
            </summary>	
            <remarks>	
            The DXGI_ADAPTER_DESC1 structure provides a DXGI 1.1 description of an adapter.  This structure is initialized by using the <see cref="M:SharpDX.DXGI.Adapter1.GetDescription1(SharpDX.DXGI.AdapterDescription1@)"/> method. 	
            </remarks>	
            <unmanaged>DXGI_ADAPTER_DESC1</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription1.Description">
            <summary>	
            A string that contains the adapter description. 	
            </summary>	
            <unmanaged>wchar_t Description[128]</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription1.VendorId">
            <summary>	
            The PCI ID of the hardware vendor. 	
            </summary>	
            <unmanaged>int VendorId</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription1.DeviceId">
            <summary>	
            The PCI ID of the hardware device. 	
            </summary>	
            <unmanaged>int DeviceId</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription1.SubsystemId">
            <summary>	
            The PCI ID of the sub system. 	
            </summary>	
            <unmanaged>int SubSysId</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription1.Revision">
            <summary>	
            The PCI ID of the revision number of the adapter. 	
            </summary>	
            <unmanaged>int Revision</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription1.DedicatedVideoMemory">
            <summary>	
            The number of bytes of dedicated video memory that are not shared with the CPU. 	
            </summary>	
            <unmanaged>SIZE_T DedicatedVideoMemory</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription1.DedicatedSystemMemory">
            <summary>	
            The number of bytes of dedicated system memory that are not shared with the GPU. This memory is allocated from available system memory at boot time. 	
            </summary>	
            <unmanaged>SIZE_T DedicatedSystemMemory</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription1.SharedSystemMemory">
            <summary>	
            The number of bytes of shared system memory. This is the maximum value of system memory that may be consumed by the adapter during operation. Any incidental memory consumed by the driver as it manages and uses video memory is additional. 	
            </summary>	
            <unmanaged>SIZE_T SharedSystemMemory</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription1.Luid">
            <summary>	
            A unique value that identifies the adapter. See {{LUID}} for a definition of the structure. LUID is defined in dxgi.h. 	
            </summary>	
            <unmanaged>__int64 AdapterLuid</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.AdapterDescription1.Flags">
            <summary>	
            A value of the <see cref="T:SharpDX.DXGI.AdapterFlags"/> enumerated type that describes the adapter type.  The DXGI_ADAPTER_FLAG_REMOTE flag is reserved. 	
            </summary>	
            <unmanaged>DXGI_ADAPTER_FLAG Flags</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.GammaControl">
            <summary>	
            Controls the settings of a gamma curve.	
            </summary>	
            <remarks>	
            The DXGI_GAMMA_CONTROL structure is used by the <see cref="M:SharpDX.DXGI.Output.SetGammaControl(SharpDX.DXGI.GammaControl@)"/> method. 	
            </remarks>	
            <unmanaged>DXGI_GAMMA_CONTROL</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.GammaControl.Scale">
            <summary>	
            A <see cref="T:SharpDX.Color4"/> structure with scalar values that are applied to rgb values before being sent to the gamma look up table. 	
            </summary>	
            <unmanaged>DXGI_RGB Scale</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.GammaControl.Offset">
            <summary>	
            A <see cref="T:SharpDX.Color4"/> structure with offset values that are applied to the rgb values before being sent to the gamma look up table. 	
            </summary>	
            <unmanaged>DXGI_RGB Offset</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.GammaControl.GammaCurve">
            <summary>	
            An array of <see cref="T:SharpDX.Color4"/> structures that control the points of a gamma curve. 	
            </summary>	
            <unmanaged>DXGI_RGB GammaCurve[1025]</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.GammaControlCapabilities">
            <summary>	
            Controls the gamma capabilities of an adapter.	
            </summary>	
            <remarks>	
            To get a list of the capabilities for controlling gamma correction, call <see cref="M:SharpDX.DXGI.Output.GetGammaControlCapabilities(SharpDX.DXGI.GammaControlCapabilities@)"/>. 	
            </remarks>	
            <unmanaged>DXGI_GAMMA_CONTROL_CAPABILITIES</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.GammaControlCapabilities.MaximumConvertedValue">
            <summary>	
            A value describing the maximum range of the control-point positions. 	
            </summary>	
            <unmanaged>float MaxConvertedValue</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.GammaControlCapabilities.MinimumConvertedValue">
            <summary>	
            A value describing the minimum range of the control-point positions. 	
            </summary>	
            <unmanaged>float MinConvertedValue</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.GammaControlCapabilities.ControlPointsCount">
            <summary>	
            A value describing the number of control points in the array. 	
            </summary>	
            <unmanaged>int NumGammaControlPoints</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.GammaControlCapabilities.IsScaleAndOffsetSupported">
            <summary>	
            True if scaling and offset operations are supported during gamma correction; otherwise, false. 	
            </summary>	
            <unmanaged>BOOL ScaleAndOffsetSupported</unmanaged>
        </member>
        <member name="P:SharpDX.DXGI.GammaControlCapabilities.ControlPoints">
            <summary>	
            An array of values describing control points; the maximum length of control points is 1025. 	
            </summary>	
            <unmanaged>float ControlPointPositions[1025]</unmanaged>
        </member>
        <member name="T:SharpDX.DXGI.Rational">
            <summary>	
            Represents a rational number.	
            </summary>	
            <remarks>	
            The DXGI_RATIONAL structure operates under the following rules:  0/0 is legal and will be interpreted as 0/1. 0/anything is interpreted as zero. If you are representing a whole number, the denominator should be 1.  	
            </remarks>	
            <unmanaged>DXGI_RATIONAL</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Rational.Numerator">
            <summary>	
            An unsigned integer value representing the top of the rational number. 	
            </summary>	
            <unmanaged>int Numerator</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.Rational.Denominator">
            <summary>	
            An unsigned integer value representing the bottom of the rational number. 	
            </summary>	
            <unmanaged>int Denominator</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.Rational.#ctor(System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref = "T:SharpDX.DXGI.Rational" /> structure.
            </summary>
            <param name = "numerator">The numerator of the rational pair.</param>
            <param name = "denominator">The denominator of the rational pair.</param>
        </member>
        <member name="T:SharpDX.DXGI.ModeDescription">
            <summary>	
            Describes a display mode.	
            </summary>	
            <unmanaged>DXGI_MODE_DESC</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.ModeDescription.Width">
            <summary>	
            A value describing the resolution width. 	
            </summary>	
            <unmanaged>int Width</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.ModeDescription.Height">
            <summary>	
            A value describing the resolution height. 	
            </summary>	
            <unmanaged>int Height</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.ModeDescription.RefreshRate">
            <summary>	
            A <see cref="T:SharpDX.DXGI.Rational"/> structure describing the refresh rate in hertz 	
            </summary>	
            <unmanaged>DXGI_RATIONAL RefreshRate</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.ModeDescription.Format">
            <summary>	
            A <see cref="T:SharpDX.DXGI.Format"/> structure describing the display format. 	
            </summary>	
            <unmanaged>DXGI_FORMAT Format</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.ModeDescription.ScanlineOrdering">
            <summary>	
            A member of the <see cref="T:SharpDX.DXGI.DisplayModeScanlineOrder"/> enumerated type describing the scanline drawing mode. 	
            </summary>	
            <unmanaged>DXGI_MODE_SCANLINE_ORDER ScanlineOrdering</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.ModeDescription.Scaling">
            <summary>	
            A member of the <see cref="T:SharpDX.DXGI.DisplayModeScaling"/> enumerated type describing the scaling mode. 	
            </summary>	
            <unmanaged>DXGI_MODE_SCALING Scaling</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.ModeDescription.#ctor(System.Int32,System.Int32,SharpDX.DXGI.Rational,SharpDX.DXGI.Format)">
            <summary>
              Initializes a new instance of the <see cref = "T:SharpDX.DXGI.ModeDescription" /> structure.
            </summary>
            <param name = "width">The width.</param>
            <param name = "height">The height.</param>
            <param name = "refreshRate">The refresh rate.</param>
            <param name = "format">The format.</param>
        </member>
        <member name="T:SharpDX.DXGI.SampleDescription">
            <summary>	
            Describes multi-sampling parameters for a resource.	
            </summary>	
            <remarks>	
            The default sampler mode, with no anti-aliasing, has a count of 1 and a quality level of 0. If multi-sample antialiasing is being used, all bound render targets and depth buffers must have the same sample counts and quality levels.   Differences between Direct3D 10.0 and Direct3D 10.1 and between Direct3D 10.0 and Direct3D 11: Direct3D 10.1 has defined two standard quality levels:   D3D10_STANDARD_MULTISAMPLE_PATTERN and D3D10_CENTER_MULTISAMPLE_PATTERN in the D3D10_STANDARD_MULTISAMPLE_QUALITY_LEVELS enumeration in D3D10_1.h. Direct3D 11 has defined two standard quality levels:   D3D11_STANDARD_MULTISAMPLE_PATTERN and D3D11_CENTER_MULTISAMPLE_PATTERN in the <see cref="!:SharpDX.Direct3D11.StandardMultisampleQualityLevels"/> enumeration in D3D11.h.   ? 	
            </remarks>	
            <unmanaged>DXGI_SAMPLE_DESC</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SampleDescription.Count">
            <summary>	
            The number of multisamples per pixel. 	
            </summary>	
            <unmanaged>int Count</unmanaged>
        </member>
        <member name="F:SharpDX.DXGI.SampleDescription.Quality">
            <summary>	
            The image quality level. The higher the quality, the lower the performance. The valid range is between zero and one less than the level returned  by <see cref="!:SharpDX.Direct3D10.Device.CheckMultisampleQualityLevels"/> for Direct3D 10 or <see cref="!:SharpDX.Direct3D11.Device.CheckMultisampleQualityLevels"/> for Direct3D 11. For Direct3D 10.1 and Direct3D 11, you can use two special quality level values. For more information about these quality level values, see Remarks. 	
            </summary>	
            <unmanaged>int Quality</unmanaged>
        </member>
        <member name="M:SharpDX.DXGI.SampleDescription.#ctor(System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref = "T:SharpDX.DXGI.SampleDescription" /> structure.
            </summary>
            <param name = "count">The sample count.</param>
            <param name = "quality">The sample quality.</param>
        </member>
    </members>
</doc>
